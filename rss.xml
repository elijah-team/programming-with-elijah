<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Programming with Elijah</title>
        <link>https://elijah-team.github.io/programming-with-elijah/</link>
        <description>This blog shows how to program in Elijah. Each post is a small tutorial and includes all needed code.</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://elijah-team.github.io/programming-with-elijah/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Tue, 29 Jun 2021 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Memory Classes</title>
                <pubDate>Tue, 29 Jun 2021 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/memory-classes/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/memory-classes/</guid>
                <description>&lt;p&gt;Memory in Elijah is under complete control of the programmer. (This may not be so in some backends such as Java, where there is only a modicum of control allowed.)  Memory models, when applied to variables allow the specification of how and when memory is allocated and released by a program.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;memory-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#memory-classes&quot; aria-label=&quot;Anchor link for: memory-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Memory Classes&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;ref &lt;&#x2F;li&gt;
&lt;li&gt;gc &lt;&#x2F;li&gt;
&lt;li&gt;pooled &lt;&#x2F;li&gt;
&lt;li&gt;manual&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;reference-counting&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reference-counting&quot; aria-label=&quot;Anchor link for: reference-counting&quot;&gt;🔗&lt;&#x2F;a&gt;Reference Counting&lt;&#x2F;h2&gt;
&lt;p&gt;From &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Reference_counting&quot;&gt;Wikipedia&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Reference counting&lt;&#x2F;em&gt; is a programming technique of storing the number of references, pointers, or handles to an object (aka a block of memory).&lt;&#x2F;p&gt;
&lt;p&gt;In garbage collection algorithms, reference counts may be used to deallocate objects that are no longer needed. &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;automatic-garbage-collection&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#automatic-garbage-collection&quot; aria-label=&quot;Anchor link for: automatic-garbage-collection&quot;&gt;🔗&lt;&#x2F;a&gt;Automatic Garbage Collection&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A garbage collector (GC) cleans up the memory when objects you allocated in your code become obsolete.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The current implementation of Elijah uses the Boehm collector (libgc).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pooled-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pooled-memory&quot; aria-label=&quot;Anchor link for: pooled-memory&quot;&gt;🔗&lt;&#x2F;a&gt;Pooled Memory&lt;&#x2F;h2&gt;
&lt;p&gt;A memory pool avoids the system allocator (&lt;code&gt;malloc&lt;&#x2F;code&gt;) when it is used right.  When it is used wrong it just wastes memory.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;manual&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#manual&quot; aria-label=&quot;Anchor link for: manual&quot;&gt;🔗&lt;&#x2F;a&gt;Manual&lt;&#x2F;h2&gt;
&lt;p&gt;This is the equivalent of just using &lt;code&gt;malloc&lt;&#x2F;code&gt; and &lt;code&gt;free&lt;&#x2F;code&gt;, or &lt;code&gt;new&lt;&#x2F;code&gt; and &lt;code&gt;delete&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;allocators&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocators&quot; aria-label=&quot;Anchor link for: allocators&quot;&gt;🔗&lt;&#x2F;a&gt;Allocators&lt;&#x2F;h2&gt;
&lt;p&gt;Each function has an implicit allocator (which is usually inherited from somewhere, like the next function up in the call stack).  It is this allocator that determines the memory profile of the function.&lt;&#x2F;p&gt;
&lt;p&gt;That means you can have a separate arena for GCed objects or a Pool for efficient use of memory without touching &lt;code&gt;malloc&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;finalizers-and-destrtuctors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#finalizers-and-destrtuctors&quot; aria-label=&quot;Anchor link for: finalizers-and-destrtuctors&quot;&gt;🔗&lt;&#x2F;a&gt;Finalizers and Destrtuctors&lt;&#x2F;h2&gt;
&lt;p&gt;Nothing to say yet&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post explains how to ...&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Overloading</title>
                <pubDate>Tue, 29 Jun 2021 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/overloading/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/overloading/</guid>
                <description>&lt;p&gt;This post explores the opportunites that Elijah gives you, the programmer, to overload or override functions. It also specifies where this behavior is not allowed.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;overloading&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-06&quot;&gt;&lt;code&gt;post-06&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overloading-operators&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overloading-operators&quot; aria-label=&quot;Anchor link for: overloading-operators&quot;&gt;🔗&lt;&#x2F;a&gt;Overloading Operators&lt;&#x2F;h2&gt;
&lt;p&gt;Overloading operators is done in the style of Python.  You define a special function (dunder method) for the operator you wish to chnage.  This is useful when you would like to improve the readability of your code for basic operations.&lt;&#x2F;p&gt;
&lt;p&gt;Overloaded operators can be defined in the class, in another class in reverse or in a namespace (usually the global or module ones).&lt;&#x2F;p&gt;
&lt;p&gt;The names of the &lt;em&gt;dunder&lt;&#x2F;em&gt; methods follow:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Operator&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Function Name&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;+&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__add__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__sub__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;*&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__mul__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__div__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;&amp;lt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__lt__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;&amp;lt;=&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__le__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__gt__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;&amp;gt;=&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__ge__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;==&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__eq__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;!=&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;__ne__&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;This is not an exhaustive list.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;overloading-functions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overloading-functions&quot; aria-label=&quot;Anchor link for: overloading-functions&quot;&gt;🔗&lt;&#x2F;a&gt;Overloading Functions&lt;&#x2F;h2&gt;
&lt;p&gt;Overloading functions is a feature from C++ and Java (and distinctly not from Python and other dynamic languages) that says that you can have multiple functions with the same name that differ only in the number of arguments or just the type of arguments.  This is useful when you want to do the same thing, but to different things, for example.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;overloading-constructors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overloading-constructors&quot; aria-label=&quot;Anchor link for: overloading-constructors&quot;&gt;🔗&lt;&#x2F;a&gt;Overloading Constructors&lt;&#x2F;h2&gt;
&lt;p&gt;Overloading constructors is basically the same as overloading functions.  You can have multiple constructors that differ only in the number of arguments or just the type of arguments.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;not-overloading-named-constructors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#not-overloading-named-constructors&quot; aria-label=&quot;Anchor link for: not-overloading-named-constructors&quot;&gt;🔗&lt;&#x2F;a&gt;Not overloading (named) constructors&lt;&#x2F;h2&gt;
&lt;p&gt;Named constructors cannot be overloaded.  That is only one per name per class is allowed.  Of course you can choose to inherit or redefine a named constructor from a base class.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post explains how ...&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Allocators</title>
                <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/allocators/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/allocators/</guid>
                <description>&lt;p&gt;Allocators are responsible for creating and removing objects from the heap.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;allocators&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-09&quot;&gt;&lt;code&gt;post-09&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;🔗&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;memory-classes&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt; gave an introduction to the concept of paging. It motivated paging by comparing it with segmentation, explained how paging and page tables work, and then introduced the 4-level page table design of &lt;code&gt;x86_64&lt;&#x2F;code&gt;. We found out that the bootloader already set up a page table hierarchy for our kernel, which means that our kernel already runs on virtual addresses. This improves safety since illegal memory accesses cause page fault exceptions instead of modifying arbitrary physical memory.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;accessing-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-page-tables&quot; aria-label=&quot;Anchor link for: accessing-page-tables&quot;&gt;🔗&lt;&#x2F;a&gt;Accessing Page Tables&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;identity-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#identity-mapping&quot; aria-label=&quot;Anchor link for: identity-mapping&quot;&gt;🔗&lt;&#x2F;a&gt;Identity Mapping&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;map-at-a-fixed-offset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-at-a-fixed-offset&quot; aria-label=&quot;Anchor link for: map-at-a-fixed-offset&quot;&gt;🔗&lt;&#x2F;a&gt;Map at a Fixed Offset&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;map-the-complete-physical-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-the-complete-physical-memory&quot; aria-label=&quot;Anchor link for: map-the-complete-physical-memory&quot;&gt;🔗&lt;&#x2F;a&gt;Map the Complete Physical Memory&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;temporary-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#temporary-mapping&quot; aria-label=&quot;Anchor link for: temporary-mapping&quot;&gt;🔗&lt;&#x2F;a&gt;Temporary Mapping&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;recursive-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recursive-page-tables&quot; aria-label=&quot;Anchor link for: recursive-page-tables&quot;&gt;🔗&lt;&#x2F;a&gt;Recursive Page Tables&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we learned about different techniques to access the physical frames of page tables, including identity mapping, mapping of the complete physical memory, temporary mapping, and recursive page tables. We chose to map the complete physical memory since it&#x27;s simple, portable, and powerful.&lt;&#x2F;p&gt;
&lt;p&gt;We can&#x27;t map the physical memory from our kernel without page table access, so we needed support from the bootloader. The &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate supports creating the required mapping through optional cargo features. It passes the required information to our kernel in the form of a &lt;code&gt;&amp;amp;BootInfo&lt;&#x2F;code&gt; argument to our entry point function.&lt;&#x2F;p&gt;
&lt;p&gt;For our implementation, we first manually traversed the page tables to implement a translation function, and then used the &lt;code&gt;MappedPageTable&lt;&#x2F;code&gt; type of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate. We also learned how to create new mappings in the page table and how to create the necessary &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; on top of the memory map passed by the bootloader.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post will create a heap memory region for our kernel, which will allow us to &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;allocate memory&lt;&#x2F;a&gt; and use various &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;index.html&quot;&gt;collection types&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Classes</title>
                <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/classes/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/classes/</guid>
                <description>&lt;p&gt;Classes are one of the fundamental building blocks of Elijah code.  This post will discuss the kinds of classes available in Elijah.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;classes&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-01&quot;&gt;&lt;code&gt;post-01&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;🔗&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;From the Python documentation:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;All classes support multiple inheritance.  Redefinition&#x2F;renaming of conflicting features (variables, properties and functions) is a &amp;quot;research topic&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;All classes support nesting and can refer to the contents of its container, where applicable (basically in normal classes).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;normal-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#normal-classes&quot; aria-label=&quot;Anchor link for: normal-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Normal Classes&lt;&#x2F;h2&gt;
&lt;p&gt;A normal class is just that -- normal.  It can be &lt;em&gt;generic&lt;&#x2F;em&gt;, but other than that it has no other special behavior in the system.  Classes are the &amp;quot;containers&amp;quot; and an organizational structure for variables and functions.  Special to classes are properties, which are basically functions that look like variables.&lt;&#x2F;p&gt;
&lt;p&gt;To interact with a class, you have to create an &lt;em&gt;instance&lt;&#x2F;em&gt;, by &lt;em&gt;constructing&lt;&#x2F;em&gt; it. See &lt;em&gt;constructors&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Classes are also special because they also represent &lt;em&gt;types&lt;&#x2F;em&gt;.  All values (variables and expressions) in Elijah have a type, which frequently is not specified, but automatically found out by a process known as &lt;em&gt;type deduction&lt;&#x2F;em&gt;.  This is functinonally similar to &lt;em&gt;type inferencing&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;interface-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#interface-classes&quot; aria-label=&quot;Anchor link for: interface-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Interface Classes&lt;&#x2F;h2&gt;
&lt;p&gt;An interface class declares a class that can&#x27;t be instantiated.  The purpose of it is to specify a set of functions (and&#x2F;or properties) which must be implemented by derived classes.  An interface can extend another interface by inheriting from it.  An interface can combine multiple interfaces into a single interface if thata is the programmer&#x27;s wish.&lt;&#x2F;p&gt;
&lt;p&gt;An interface can contain default behavior (as Java was recently extended to implement) for functions that can be inherited or overridden by derived classes.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;An interface can override its inherited default behaviors too.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;An interface can contain properties, which can be &lt;code&gt;abstract&lt;&#x2F;code&gt;.  They usually are because properties usually utilize the member variables of a class.
An interface cannot contain variables or abstract methods.  An interface usually contains just function headers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;signature-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#signature-classes&quot; aria-label=&quot;Anchor link for: signature-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Signature Classes&lt;&#x2F;h2&gt;
&lt;p&gt;A signature class can only contain function headers.  That means &lt;em&gt;contracts&lt;&#x2F;em&gt; are not supported, and neither is the default specification of behaviors.  It only exists at compile time and cannot be tested for (using &lt;code&gt;is_a&lt;&#x2F;code&gt;).  It&#x27;s purpose is to specify a set of functions that must be implemeted by derived classes.  It is kind of like pattern matching for classes.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Maybe we can relax the can&#x27;t be tested for thing...&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;abstract-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#abstract-classes&quot; aria-label=&quot;Anchor link for: abstract-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Abstract Classes&lt;&#x2F;h2&gt;
&lt;p&gt;Abstract classes extend the conception of interfaces by allowing the specification of functions with &lt;em&gt;contracts&lt;&#x2F;em&gt; but no implementation (meaning they are abstract) and allowing the inclusion of variables and non-abstract properties.&lt;&#x2F;p&gt;
&lt;p&gt;An abstract class is meant to define default behavior for a set of derived classes.&lt;&#x2F;p&gt;
&lt;p&gt;An abstract class cannot be instantiated.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enum-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#enum-classes&quot; aria-label=&quot;Anchor link for: enum-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Enum Classes&lt;&#x2F;h2&gt;
&lt;p&gt;Enums exist to group the possible states of a variable.  Enums are very similar to &lt;code&gt;datatype&lt;&#x2F;code&gt;s and very similar to classes and can be looked at as the combination of the two.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;enum&lt;&#x2F;code&gt; classes in Elijah are the same as they are in Java.  Each variant can contain a number of attributes or none at all (but it is an all or  nothing choice, unlike &lt;code&gt;datatypes&lt;&#x2F;code&gt;).  Also each variant can contain implementations of abstract methods defined in the body of the enum itself, thus allowing the differentiation of variant states without defining functions in a separate namespace.&lt;&#x2F;p&gt;
&lt;p&gt;Enums can contain only one constructor and only one named constructor called copy, which would take a single value of the same enum type.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;datatypes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#datatypes&quot; aria-label=&quot;Anchor link for: datatypes&quot;&gt;🔗&lt;&#x2F;a&gt;Datatypes&lt;&#x2F;h2&gt;
&lt;p&gt;A datatype is an enumeration of known states.  In fact, in Rust, it is called an &lt;code&gt;enum&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Datatypes have a special syntax:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;datatype Boolean = 
  True
  | False
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is, they do not allow the definition of functions alongside of the rest of the declaration.  Functions which take a &lt;code&gt;datatype&lt;&#x2F;code&gt; as &lt;code&gt;self&lt;&#x2F;code&gt; are rare because they are usually used in pattern matching in &lt;code&gt;match&lt;&#x2F;code&gt; clauses.  But it is customary to declare those functions that do in a parallel namespace with an underscore affixed.&lt;&#x2F;p&gt;
&lt;p&gt;Datatypes allow data to be attached to instances.  Instances are only created when there is data to be attached.  &lt;code&gt;True&lt;&#x2F;code&gt; and &lt;code&gt;False&lt;&#x2F;code&gt; above are singletons, and may be represented as integers by the compiler.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;datatype Maybe[T] = 
  Some(t: T)
  | Nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Note this type is &lt;em&gt;generic&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Datatypes are immutable, that is, once created, their values cannot be changed.&lt;&#x2F;p&gt;
&lt;p&gt;This says either you have &lt;code&gt;Some&lt;&#x2F;code&gt; value &lt;code&gt;t&lt;&#x2F;code&gt; of generic type &lt;code&gt;T&lt;&#x2F;code&gt;, or you have &lt;code&gt;Nothing&lt;&#x2F;code&gt;.  Note that &lt;code&gt;t&lt;&#x2F;code&gt; cannot be assigned to -- it&#x27;s value can never be changed.&lt;&#x2F;p&gt;
&lt;p&gt;Datatypes can also have &amp;quot;universal&amp;quot; attributes -- these values are present in all variants of the datatype.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;datatype Message(id: Integer32) {
  Quit
  | Move ( x: i32, y: i32 )
  | Write(String)
  | ChangeColor(i32, i32, i32)
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that all variants have and &lt;code&gt;id&lt;&#x2F;code&gt; attribute, and each variant has a different number of individual attrbutes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;annotation-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#annotation-classes&quot; aria-label=&quot;Anchor link for: annotation-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Annotation Classes&lt;&#x2F;h2&gt;
&lt;p&gt;Annotations are declared by inheriting from &lt;code&gt;tripleo.lang.Annotation&lt;&#x2F;code&gt;. I don&#x27;t want to use a keyword for this right now.
I don&#x27;t know what effect annotations will have on the code produced by the Elijah compiler.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;exception-classes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exception-classes&quot; aria-label=&quot;Anchor link for: exception-classes&quot;&gt;🔗&lt;&#x2F;a&gt;Exception Classes&lt;&#x2F;h2&gt;
&lt;p&gt;Exceptions are declared by inheriting from &lt;code&gt;tripleo.lang.Exception&lt;&#x2F;code&gt;. I don&#x27;t want to use a keyword for this right now.
For Java interopability, you can use the annotation &lt;code&gt;ExceptionType(Error | Throwable)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rustup target add thumbv7em-none-eabihf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This downloads a copy of the standard (and core) library for the system. Now we can build our freestanding executable for this target:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo build --target thumbv7em-none-eabihf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;There are a number of different types of classes in Elijah, and some of them overlap, but they are for different programming styles or tastes.  Each has its benefits and each has its purpose.  To effectively program in Elijah it is necessary to master each one.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;namespaces-and-packages&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; how to organize classes to make them part of a cohesive whole.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Libraries and Executables</title>
                <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/libraries-and-executables/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/libraries-and-executables/</guid>
                <description>&lt;p&gt;Building and publishing your software is only possible if the compiler knows how to find it.  Below, find an overview of the &lt;code&gt;.ez&lt;&#x2F;code&gt; file format.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;libraries-and-executables&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-03&quot;&gt;&lt;code&gt;post-03&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;🔗&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;Elijah &amp;quot;program text&amp;quot; is contained in &amp;quot;modules&amp;quot;.  Some languages call them &amp;quot;compilation units&amp;quot;.  Either way, a module consists of &lt;code&gt;import&lt;&#x2F;code&gt; statements, &lt;code&gt;alias&lt;&#x2F;code&gt; statements, classes and namespaces, among other things.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A module is just a fancy name for a file, unless you&#x27;re using [scid][&lt;em&gt;Source code as a Database&lt;&#x2F;em&gt;].&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;But unlike some other languages you don&#x27;t specify files to compile on the command line (or in your make tool, which in Elijah&#x27;s case, happens to be integraeted with the compiler).  You specify an &lt;code&gt;.ez&lt;&#x2F;code&gt; file that tells the compiler two things: where to find your code, and a little about how to generate it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we learned about the structure of the VGA text buffer and how it can be written through the memory mapping at address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. We created a Rust module that encapsulates the unsafety of writing to this memory mapped buffer and presents a safe and convenient interface to the outside.&lt;&#x2F;p&gt;
&lt;p&gt;We also saw how easy it is to add dependencies on third-party libraries, thanks to cargo. The two dependencies that we added, &lt;code&gt;lazy_static&lt;&#x2F;code&gt; and &lt;code&gt;spin&lt;&#x2F;code&gt;, are very useful in OS development and we will use them in more places in future posts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post explains how to set up Rust&#x27;s built in unit test framework. We will then create some basic unit tests for the VGA buffer module from this post.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Namespaces and Packages</title>
                <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/namespaces-and-packages/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/namespaces-and-packages/</guid>
                <description>&lt;p&gt;Namespaces and packages are essential to keep your code orderly and to use code written by other people.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;namespaces-and-packages&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-02&quot;&gt;&lt;code&gt;post-02&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;namespaces&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#namespaces&quot; aria-label=&quot;Anchor link for: namespaces&quot;&gt;🔗&lt;&#x2F;a&gt;Namespaces&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;Namespaces&lt;&#x2F;em&gt; are an idea from C++ (and C# admittedly), originally intended only to support the production and use of C functions without name mangling.  Now this was before annotations, so bear with me.  They are still used for that purpose, but can serve a dual role as an organizer of code.&lt;&#x2F;p&gt;
&lt;p&gt;See, namespaces are singletons.  Some people don&#x27;t like singletons (and they are hard to mock), but, nevertheless, they made it into the language.&lt;&#x2F;p&gt;
&lt;p&gt;Namespaces can be normal or instance.  Instance namespaces are created on first access, similar to how static classes work in Java.  This feature was added to solve the non-deterministic creation problem -- normal namespaces are created at program invocation (start) in what may not always be the same order.  This is not always important, and there are other ways around this, but instance namespaces are the simplest.&lt;&#x2F;p&gt;
&lt;p&gt;It would seem that namespaces perform the same duty as packages, but namespaces in Elijah are mainly used for grouping of functionality and information hiding.  They also perform the same function as static (or class in Smalltalk) members in other languages.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;packages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#packages&quot; aria-label=&quot;Anchor link for: packages&quot;&gt;🔗&lt;&#x2F;a&gt;Packages&lt;&#x2F;h2&gt;
&lt;p&gt;Packages are ripped straight from Java.  They are the top level of organization in a module (or file).&lt;&#x2F;p&gt;
&lt;p&gt;More...&lt;&#x2F;p&gt;
&lt;h2 id=&quot;imports&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#imports&quot; aria-label=&quot;Anchor link for: imports&quot;&gt;🔗&lt;&#x2F;a&gt;Imports&lt;&#x2F;h2&gt;
&lt;p&gt;...&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the next post, we will explore the VGA text buffer in more detail and write a safe interface for it. We will also add support for the &lt;code&gt;println&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Testing</title>
                <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/testing/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/testing/</guid>
                <description>&lt;p&gt;This post explores testing.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;testing&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-04&quot;&gt;&lt;code&gt;post-04&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;🔗&lt;&#x2F;a&gt;Requirements&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;testing-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-in-rust&quot; aria-label=&quot;Anchor link for: testing-in-rust&quot;&gt;🔗&lt;&#x2F;a&gt;Testing in Rust&lt;&#x2F;h2&gt;
&lt;p&gt;Since the &lt;code&gt;test&lt;&#x2F;code&gt; crate depends on the standard library, it is not available for our bare metal target. While porting the &lt;code&gt;test&lt;&#x2F;code&gt; crate to a &lt;code&gt;#[no_std]&lt;&#x2F;code&gt; context &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;japaric&#x2F;utest&quot;&gt;is possible&lt;&#x2F;a&gt;, it is highly unstable and requires some hacks such as redefining the &lt;code&gt;panic&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;custom-test-frameworks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#custom-test-frameworks&quot; aria-label=&quot;Anchor link for: custom-test-frameworks&quot;&gt;🔗&lt;&#x2F;a&gt;Custom Test Frameworks&lt;&#x2F;h3&gt;
&lt;div class = &quot;warning&quot;&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; There is currently a bug in cargo that leads to &amp;quot;duplicate lang item&amp;quot; errors on &lt;code&gt;cargo test&lt;&#x2F;code&gt; in some cases. It occurs when you have set &lt;code&gt;panic = &amp;quot;abort&amp;quot;&lt;&#x2F;code&gt; for a profile in your &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;. Try removing it, then &lt;code&gt;cargo test&lt;&#x2F;code&gt; should work. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;7359&quot;&gt;cargo issue&lt;&#x2F;a&gt; for more information on this.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;h2 id=&quot;exiting-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exiting-qemu&quot; aria-label=&quot;Anchor link for: exiting-qemu&quot;&gt;🔗&lt;&#x2F;a&gt;Exiting QEMU&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;i-o-ports&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#i-o-ports&quot; aria-label=&quot;Anchor link for: i-o-ports&quot;&gt;🔗&lt;&#x2F;a&gt;I&#x2F;O Ports&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Testing is a very useful technique to ensure that certain components have a desired behavior. Even if they cannot show the absence of bugs, they&#x27;re still an useful tool for finding them and especially for avoiding regressions.&lt;&#x2F;p&gt;
&lt;p&gt;This post explained how to set up a test framework for our Rust kernel. We used the custom test frameworks feature of Rust to implement support for a simple &lt;code&gt;#[test_case]&lt;&#x2F;code&gt; attribute in our bare-metal environment. By using the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device of QEMU, our test runner can exit QEMU after running the tests and report the test status out. To print error messages to the console instead of the VGA buffer, we created a basic driver for the serial port.&lt;&#x2F;p&gt;
&lt;p&gt;After creating some tests for our &lt;code&gt;println&lt;&#x2F;code&gt; macro, we explored integration tests in the second half of the post. We learned that they live in the &lt;code&gt;tests&lt;&#x2F;code&gt; directory and are treated as completely separate executables. To give them access to the &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; function and the &lt;code&gt;serial_println&lt;&#x2F;code&gt; macro, we moved most of our code into a library that can be imported by all executables and integration tests. Since integration tests run in their own separate environment, they make it possible to test interactions with the hardware or to create tests that should panic.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a test framework that runs in a realistic environment inside QEMU. By creating more tests in future posts, we can keep our kernel maintainable when it becomes more complex.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the next post, we will explore &lt;em&gt;CPU exceptions&lt;&#x2F;em&gt;. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called “page fault”). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in March 2020</title>
                <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2020-04-01/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2020-04-01/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I focused my time this month on finishing the long-planned post about &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;async-await&#x2F;&quot;&gt;&lt;strong&gt;Async&#x2F;Await&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;. In addition to that, there were a few updates to the crates behind the scenes, including some great contributions and a new &lt;code&gt;vga&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned in the &lt;em&gt;Async&#x2F;Await&lt;&#x2F;em&gt; post, I&#x27;m currently looking for job in Karlsruhe (Germany) or remote, so please let me know if you&#x27;re interested.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;763&quot;&gt;Update linked_list_allocator to v0.8.0&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;764&quot;&gt;Update x86_64 dependency to version 0.9.6&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;767&quot;&gt;New post about Async&#x2F;Await&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;774&quot;&gt;Discuss the approach of storing offsets for self-referential structs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;782&quot;&gt;Use a static counter for assigning task IDs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In addition to the changes above, there were a lot of &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pulls?q=is%3Apr+is%3Aclosed+created%3A2020-03-01..2020-04-02+-author%3Aphil-opp+&quot;&gt;typo fixes&lt;&#x2F;a&gt; by external contributors. Thanks a lot!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides support for CPU-specific instructions, registers, and data structures of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; architecture. In March, there was only a single addition, which was required for the &lt;em&gt;Async&#x2F;Await&lt;&#x2F;em&gt; post:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;138&quot;&gt;Add an enable_interrupts_and_hlt function that executes &lt;code&gt;sti; hlt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.6)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The bootloader crate received two contributions this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;101&quot;&gt;Implement boot-info-address&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Darksecond&quot;&gt;@Darksecond&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.9)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;104&quot;&gt;Identity-map complete vga region (0xa0000 to 0xc0000)&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RKennedy9064&quot;&gt;@RKennedy9064&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.0)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool builds the &lt;code&gt;bootloader&lt;&#x2F;code&gt; and creates a bootable disk image from a kernel. It received a RUSTFLAGS-related bugfix:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;51&quot;&gt;Set empty RUSTFLAGS to ensure that no .cargo&#x2F;config applies&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!--

## `cargo-xbuild`

The `cargo-xbuild` crate provides support for cross-compiling `libcore` and `liballoc`. There were no updates to it this month.

## `uart_16550`

The `uart_16550` crate provides basic support for uart_16550 serial output. It received no updates this month.

## `multiboot2-elf64`

The `multiboot2-elf64` crate provides abstractions for reading the boot information of the multiboot 2 standard, which is implemented by bootloaders like GRUB. There were no updates to the crate in March.

--&gt;
&lt;h2 id=&quot;vga&quot;&gt;&lt;code&gt;vga&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There is a new crate under the &lt;code&gt;rust-osdev&lt;&#x2F;code&gt; organization: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;vga&quot;&gt;&lt;code&gt;vga&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; created by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RKennedy9064&quot;&gt;@RKennedy9064&lt;&#x2F;a&gt;. The purpose of the library is to provide abstractions for the VGA hardware. For example, the crate allows to switch the VGA hardware to graphics mode, which makes it possible to draw on a pixel-based framebuffer:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;status-update&#x2F;2020-04-01&#x2F;qemu-vga-crate.png&quot; alt=&quot;QEMU printing a box with &amp;quot;Hello World&amp;quot; in it&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For more information about the crate, check out its &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;vga&#x2F;0.2.2&#x2F;vga&#x2F;&quot;&gt;API documentation&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;vga&quot;&gt;GitHub repository&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Async&#x2F;Await</title>
                <pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/async-await/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/async-await/</guid>
                <description>&lt;p&gt;In this post we explore &lt;em&gt;cooperative multitasking&lt;&#x2F;em&gt; and the &lt;em&gt;async&#x2F;await&lt;&#x2F;em&gt; feature of Rust. We take a detailed look how async&#x2F;await works in Rust, including the design of the &lt;code&gt;Future&lt;&#x2F;code&gt; trait, the state machine transformation, and &lt;em&gt;pinning&lt;&#x2F;em&gt;. We then add basic support for async&#x2F;await to our kernel by creating an asynchronous keyboard task and a basic executor.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;async-await&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-12&quot;&gt;&lt;code&gt;post-12&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;multitasking&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multitasking&quot; aria-label=&quot;Anchor link for: multitasking&quot;&gt;🔗&lt;&#x2F;a&gt;Multitasking&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;We started this post by introducing &lt;strong&gt;multitasking&lt;&#x2F;strong&gt; and differentiating between &lt;em&gt;preemptive&lt;&#x2F;em&gt; multitasking, which forcibly interrupts running tasks regularly, and &lt;em&gt;cooperative&lt;&#x2F;em&gt; multitasking, which lets tasks run until they voluntarily give up control of the CPU.&lt;&#x2F;p&gt;
&lt;p&gt;We then explored how Rust&#x27;s support of &lt;strong&gt;async&#x2F;await&lt;&#x2F;strong&gt; provides a language-level implementation of cooperative multitasking. Rust bases its implementation on top of the polling-based &lt;code&gt;Future&lt;&#x2F;code&gt; trait, which abstracts asynchronous tasks. Using async&#x2F;await, it is possible to work with futures almost like with normal synchronous code. The difference is that asynchronous functions return a &lt;code&gt;Future&lt;&#x2F;code&gt; again, which needs to be added to an executor at some point in order to run it.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, the compiler transforms async&#x2F;await code to &lt;em&gt;state machines&lt;&#x2F;em&gt;, with each &lt;code&gt;.await&lt;&#x2F;code&gt; operation corresponding to a possible pause point. By utilizing its knowledge about the program, the compiler is able to save only the minimal state for each pause point, resulting in a very small memory consumption per task. One challenge is that the generated state machines might contain &lt;em&gt;self-referential&lt;&#x2F;em&gt; structs, for example when local variables of the asynchronous function reference each other. To prevent pointer invalidation, Rust uses the &lt;code&gt;Pin&lt;&#x2F;code&gt; type to ensure that futures cannot be moved in memory anymore after they have been polled for the first time.&lt;&#x2F;p&gt;
&lt;p&gt;For our &lt;strong&gt;implementation&lt;&#x2F;strong&gt;, we first created a very basic executor that polls all spawned tasks in a busy loop without using the &lt;code&gt;Waker&lt;&#x2F;code&gt; type at all. We then showed the advantage of waker notifications by implementing an asynchronous keyboard task. The task defines a static &lt;code&gt;SCANCODE_QUEUE&lt;&#x2F;code&gt; using the mutex-free &lt;code&gt;ArrayQueue&lt;&#x2F;code&gt; type provided by the &lt;code&gt;crossbeam&lt;&#x2F;code&gt; crate. Instead of handling keypresses directly, the keyboard interrupt handler now puts all received scancodes in the queue and then wakes the registered &lt;code&gt;Waker&lt;&#x2F;code&gt; to signal that new input is available. On the receiving end, we created a &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; type to provide a &lt;code&gt;Future&lt;&#x2F;code&gt; resolving to the next scancode in the queue. This made it possible to create an asynchronous &lt;code&gt;print_keypresses&lt;&#x2F;code&gt; task that uses async&#x2F;await to interpret and print the scancodes in the queue.&lt;&#x2F;p&gt;
&lt;p&gt;To utilize the waker notifications of the keyboard task, we created a new &lt;code&gt;Executor&lt;&#x2F;code&gt; type that uses an &lt;code&gt;Arc&lt;&#x2F;code&gt;-shared &lt;code&gt;task_queue&lt;&#x2F;code&gt; for ready tasks. We implemented a &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; type that pushes the ID of woken tasks directly to this &lt;code&gt;task_queue&lt;&#x2F;code&gt;, which are then polled again by the executor. To save power when no tasks are runnable, we added support for putting the CPU to sleep using the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction. Finally, we discussed some potential extensions of our executor, for example for providing multi-core support.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s Next?&lt;&#x2F;h2&gt;
&lt;p&gt;Using async&#x2F;wait, we now have basic support for cooperative multitasking in our kernel. While cooperative multitasking is very efficient, it leads to latency problems when individual tasks keep running for too long and thus prevent other tasks to run. For this reason, it makes sense to also add support for preemptive multitasking to our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;In the next post, we will introduce &lt;em&gt;threads&lt;&#x2F;em&gt; as the most common form of preemptive multitasking. In addition to resolving the problem of long running tasks, threads will also prepare us for utilizing multiple CPU cores and running untrusted user programs in the future.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Portability and Code Generation</title>
                <pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/portability-and-code-generation/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/portability-and-code-generation/</guid>
                <description>&lt;p&gt;In this post we explore &lt;em&gt;cooperative multitasking&lt;&#x2F;em&gt; and the &lt;em&gt;async&#x2F;await&lt;&#x2F;em&gt; feature of Rust. We take a detailed look how async&#x2F;await works in Rust, including the design of the &lt;code&gt;Future&lt;&#x2F;code&gt; trait, the state machine transformation, and &lt;em&gt;pinning&lt;&#x2F;em&gt;. We then add basic support for async&#x2F;await to our kernel by creating an asynchronous keyboard task and a basic executor.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;portability-and-code-generation&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-12&quot;&gt;&lt;code&gt;post-12&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;We started this post by introducing &lt;strong&gt;multitasking&lt;&#x2F;strong&gt; and differentiating between &lt;em&gt;preemptive&lt;&#x2F;em&gt; multitasking, which forcibly interrupts running tasks regularly, and &lt;em&gt;cooperative&lt;&#x2F;em&gt; multitasking, which lets tasks run until they voluntarily give up control of the CPU.&lt;&#x2F;p&gt;
&lt;p&gt;We then explored how Rust&#x27;s support of &lt;strong&gt;async&#x2F;await&lt;&#x2F;strong&gt; provides a language-level implementation of cooperative multitasking. Rust bases its implementation on top of the polling-based &lt;code&gt;Future&lt;&#x2F;code&gt; trait, which abstracts asynchronous tasks. Using async&#x2F;await, it is possible to work with futures almost like with normal synchronous code. The difference is that asynchronous functions return a &lt;code&gt;Future&lt;&#x2F;code&gt; again, which needs to be added to an executor at some point in order to run it.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, the compiler transforms async&#x2F;await code to &lt;em&gt;state machines&lt;&#x2F;em&gt;, with each &lt;code&gt;.await&lt;&#x2F;code&gt; operation corresponding to a possible pause point. By utilizing its knowledge about the program, the compiler is able to save only the minimal state for each pause point, resulting in a very small memory consumption per task. One challenge is that the generated state machines might contain &lt;em&gt;self-referential&lt;&#x2F;em&gt; structs, for example when local variables of the asynchronous function reference each other. To prevent pointer invalidation, Rust uses the &lt;code&gt;Pin&lt;&#x2F;code&gt; type to ensure that futures cannot be moved in memory anymore after they have been polled for the first time.&lt;&#x2F;p&gt;
&lt;p&gt;For our &lt;strong&gt;implementation&lt;&#x2F;strong&gt;, we first created a very basic executor that polls all spawned tasks in a busy loop without using the &lt;code&gt;Waker&lt;&#x2F;code&gt; type at all. We then showed the advantage of waker notifications by implementing an asynchronous keyboard task. The task defines a static &lt;code&gt;SCANCODE_QUEUE&lt;&#x2F;code&gt; using the mutex-free &lt;code&gt;ArrayQueue&lt;&#x2F;code&gt; type provided by the &lt;code&gt;crossbeam&lt;&#x2F;code&gt; crate. Instead of handling keypresses directly, the keyboard interrupt handler now puts all received scancodes in the queue and then wakes the registered &lt;code&gt;Waker&lt;&#x2F;code&gt; to signal that new input is available. On the receiving end, we created a &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; type to provide a &lt;code&gt;Future&lt;&#x2F;code&gt; resolving to the next scancode in the queue. This made it possible to create an asynchronous &lt;code&gt;print_keypresses&lt;&#x2F;code&gt; task that uses async&#x2F;await to interpret and print the scancodes in the queue.&lt;&#x2F;p&gt;
&lt;p&gt;To utilize the waker notifications of the keyboard task, we created a new &lt;code&gt;Executor&lt;&#x2F;code&gt; type that uses an &lt;code&gt;Arc&lt;&#x2F;code&gt;-shared &lt;code&gt;task_queue&lt;&#x2F;code&gt; for ready tasks. We implemented a &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; type that pushes the ID of woken tasks directly to this &lt;code&gt;task_queue&lt;&#x2F;code&gt;, which are then polled again by the executor. To save power when no tasks are runnable, we added support for putting the CPU to sleep using the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction. Finally, we discussed some potential extensions of our executor, for example for providing multi-core support.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s Next?&lt;&#x2F;h2&gt;
&lt;p&gt;Using async&#x2F;wait, we now have basic support for cooperative multitasking in our kernel. While cooperative multitasking is very efficient, it leads to latency problems when individual tasks keep running for too long and thus prevent other tasks to run. For this reason, it makes sense to also add support for preemptive multitasking to our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;In the next post, we will introduce &lt;em&gt;threads&lt;&#x2F;em&gt; as the most common form of preemptive multitasking. In addition to resolving the problem of long running tasks, threads will also prepare us for utilizing multiple CPU cores and running untrusted user programs in the future.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in February 2020</title>
                <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2020-03-02/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2020-03-02/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;722&quot;&gt;Mention potential bump allocator extensions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;738&quot;&gt;Don&#x27;t panic on overflow in allocator; return null pointer instead&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;739&quot;&gt;Update Allocator Designs post to signal OOM instead of panicking on overflow&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;747&quot;&gt;Update to Zola 0.10&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;692&quot;&gt;Experimental Support for Community Translations&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;694&quot;&gt;Add translations from rustcc&#x2F;writing-an-os-in-rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;748&quot;&gt;Some fixes to generated translations&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;749&quot;&gt;Add metadata to translations and list translators&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;752&quot;&gt;Add a language selector for browser-supported languages&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;751&quot;&gt;Use zola check to check for dead links; fix all dead links found&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;commit&#x2F;0619f3a9e766c575ba1a4f2c6825049c177f8c70&quot;&gt;Convert all external links to https (if supported)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;732&quot;&gt;Mention in &amp;quot;Paging Introduction&amp;quot; that a CPU with 5-level paging is available now&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;commit&#x2F;b532c052add9d3eac18663f1836bc9eee11007af&quot;&gt;Double Faults: A missing handler leads to a #GP exception (not a #NP)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;756&quot;&gt;Updated pc-keyboard to &lt;code&gt;0.5.0&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RKennedy9064&quot;&gt;@RKennedy9064&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides support for CPU-specific instructions, registers, and data structures of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; architecture. There were lots of great contributions this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;119&quot;&gt;Add User Mode registers&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released together with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;118&quot;&gt;#118&lt;&#x2F;a&gt; as v0.9.0)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;122&quot;&gt;Improve PageTableIndex and PageOffset&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.1)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;124&quot;&gt;Remove the &lt;code&gt;cast&lt;&#x2F;code&gt; dependency&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.2)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;126&quot;&gt;Fix GitHub actions to run latest available rustfmt&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;127&quot;&gt;Enable usage with non-nightly rust&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.3)&lt;&#x2F;span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;128&quot;&gt;asm: add target_env = &amp;quot;musl&amp;quot; to pickup the underscore asm names&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.4)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;129&quot;&gt;Add &lt;code&gt;#[inline]&lt;&#x2F;code&gt; attribute to small functions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;AntoineSebert&quot;&gt;@AntoineSebert&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.5)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;130&quot;&gt;Fix clippy warnings&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;AntoineSebert&quot;&gt;@AntoineSebert&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;132&quot;&gt;Resolve remaining clippy warnings and add clippy job to CI&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The bootloader crate received two small bugfixes and one new feature this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;94&quot;&gt;Objcopy replaces &lt;code&gt;.&lt;&#x2F;code&gt; chars with &lt;code&gt;_&lt;&#x2F;code&gt; chars&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.6)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;commit&#x2F;af4f1016aa19fec3271226f8bfc2145521cf0c98&quot;&gt;Fix docs.rs build by specifying an explicit target&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.7)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;96&quot;&gt;Add basic support for ELF thread local storage segments&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.8)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool this month.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate provides support for cross-compiling &lt;code&gt;libcore&lt;&#x2F;code&gt; and &lt;code&gt;liballoc&lt;&#x2F;code&gt;. It received the following contributions this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;56&quot;&gt;Added new option to the configuration table&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;56&quot;&gt;@parraman&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released an v0.5.22)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;57&quot;&gt;Pick up xbuild config from workspace manifest&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ascjones&quot;&gt;@ascjones&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.23)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;59&quot;&gt;Make &lt;code&gt;fn build&lt;&#x2F;code&gt; and &lt;code&gt;Args&lt;&#x2F;code&gt; public to enable use as lib&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ascjones&quot;&gt;@ascjones&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.24)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;61&quot;&gt;Fix: Not all projects have a root package&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.25)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;62&quot;&gt;Improvements to args and config for lib usage&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ascjones&quot;&gt;@ascjones&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.26)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;64&quot;&gt;Add &lt;code&gt;cargo xfix&lt;&#x2F;code&gt; command&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tjhu&quot;&gt;@tjhu&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.27)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;65&quot;&gt;Update dependencies&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;parasyte&quot;&gt;@parasyte&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.28)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;uart-16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2F;code&gt; crate, which provides basic support for uart_16550 serial output, received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;6&quot;&gt;Switch CI to GitHub Actions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;5&quot;&gt;Cargo.toml: update x86_64 dependency&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.2.3)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;7&quot;&gt;Enable usage with non-nightly rust&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.2.4)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;multiboot2-elf64&quot;&gt;&lt;code&gt;multiboot2-elf64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;multiboot2-elf64&lt;&#x2F;code&gt; crate provides abstractions for reading the boot information of the multiboot 2 standard, which is implemented by bootloaders like GRUB. There were two updates to the crate in February:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;multiboot2-elf64&#x2F;pull&#x2F;61&quot;&gt;Add MemoryAreaType, to allow users to access memory area types in a type-safe way&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CWood1&quot;&gt;@CWood1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;multiboot2-elf64&#x2F;pull&#x2F;62&quot;&gt;Add some basic documentation&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;multiboot2-elf64&#x2F;pull&#x2F;62&quot;&gt;@mental32&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.2)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in January 2020</title>
                <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2020-02-01/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2020-02-01/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;714&quot;&gt;Move #[global_allocator] into allocator module&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;716&quot;&gt;Update many_boxes test to scale with heap size&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;719&quot;&gt;New post about allocator designs&lt;&#x2F;a&gt; 🎉&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;721&quot;&gt;Provide multiple implementations of align_up and mention performance&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;725&quot;&gt;Refactor Simplified Chinese translation of post 3&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rustin-Liu&quot;&gt;@Rustin-Liu&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;726&quot;&gt;Use checked addition for allocator implementations&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;728&quot;&gt;Fix dummy allocator code example&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;729&quot;&gt;Some style updates to the front page&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;733&quot;&gt;Mark active item in table of contents&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;734&quot;&gt;Make active section link more discreet&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Menschenkindlein&quot;&gt;@Menschenkindlein&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I also started working on the upcoming post about threads.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The bootloader crate received two minor updates this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;91&quot;&gt;Move architecture checks from build script into lib.rs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;92&quot;&gt;Update x86_64 dependency to version 0.8.3&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Since I focused my time on the new &lt;em&gt;Allocator Designs&lt;&#x2F;em&gt; post, I did not have the time to make more progress on my plan to rewrite the 16-bit&#x2F;32-bit stages of the bootloader in Rust. I hope to get back to it soon.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool this month.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The following changes were merged this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;115&quot;&gt;Allow immediate port version of in&#x2F;out instructions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;116&quot;&gt;Make more functions const&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Released as version 0.8.3&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;118&quot;&gt;Return the UnusedPhysFrame on MapToError::PageAlreadyMapped&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;This is a &lt;strong&gt;breaking change&lt;&#x2F;strong&gt; since it changes the signature of a type.&lt;&#x2F;li&gt;
&lt;li&gt;No new release was published yet to give us the option to bundle it with other breaking changes.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There are also some pull requests that have some open design questions and are still being discussed:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;114&quot;&gt;Add p23_insert_flag_mask argument to mapper.map_to()&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Related proposal: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;issues&#x2F;121&quot;&gt;Page Table Visitors&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mark-i-m&quot;&gt;@mark-i-m&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;119&quot;&gt;Add User Mode registers&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Please feel free to join these discussions if you have opinions on the matter.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate, which cross-compiles the sysroot, received the following updates this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;52&quot;&gt;Override target path for building sysroot&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;upsuper&quot;&gt;@upsuper&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Published as version 0.5.21&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;uart-16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2F;code&gt; crate, which provides basic support for uart_16550 serial output, received a small dependency update:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;4&quot;&gt;Update dependency for x86_64&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Published as version 0.2.2&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Allocator Designs</title>
                <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/allocator-designs/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/allocator-designs/</guid>
                <description>&lt;p&gt;This post explains how to implement heap allocators from scratch. It presents and discusses different allocator designs, including bump allocation, linked list allocation, and fixed-size block allocation. For each of the three designs, we will create a basic implementation that can be used for our kernel.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;allocator-designs&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-11&quot;&gt;&lt;code&gt;post-11&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;🔗&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;design-goals&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#design-goals&quot; aria-label=&quot;Anchor link for: design-goals&quot;&gt;🔗&lt;&#x2F;a&gt;Design Goals&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bump-allocator&quot; aria-label=&quot;Anchor link for: bump-allocator&quot;&gt;🔗&lt;&#x2F;a&gt;Bump Allocator&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;idea&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#idea&quot; aria-label=&quot;Anchor link for: idea&quot;&gt;🔗&lt;&#x2F;a&gt;Idea&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;🔗&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;globalalloc-and-mutability&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#globalalloc-and-mutability&quot; aria-label=&quot;Anchor link for: globalalloc-and-mutability&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; and Mutability&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;a-locked-wrapper-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-locked-wrapper-type&quot; aria-label=&quot;Anchor link for: a-locked-wrapper-type&quot;&gt;🔗&lt;&#x2F;a&gt;A &lt;code&gt;Locked&lt;&#x2F;code&gt; Wrapper Type&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;implementation-for-locked-bumpallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-for-locked-bumpallocator&quot; aria-label=&quot;Anchor link for: implementation-for-locked-bumpallocator&quot;&gt;🔗&lt;&#x2F;a&gt;Implementation for &lt;code&gt;Locked&amp;lt;BumpAllocator&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;address-alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#address-alignment&quot; aria-label=&quot;Anchor link for: address-alignment&quot;&gt;🔗&lt;&#x2F;a&gt;Address Alignment&lt;&#x2F;h4&gt;
&lt;h3 id=&quot;discussion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#discussion&quot; aria-label=&quot;Anchor link for: discussion&quot;&gt;🔗&lt;&#x2F;a&gt;Discussion&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;the-drawback-of-a-bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-drawback-of-a-bump-allocator&quot; aria-label=&quot;Anchor link for: the-drawback-of-a-bump-allocator&quot;&gt;🔗&lt;&#x2F;a&gt;The Drawback of a Bump Allocator&lt;&#x2F;h4&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;With this post, we conclude our memory management implementation for now. Next, we will start exploring &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computer_multitasking&quot;&gt;&lt;em&gt;multitasking&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, starting with &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_(computing)&quot;&gt;&lt;em&gt;threads&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. In subsequent post we will then explore &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiprocessing&quot;&gt;&lt;em&gt;multiprocessing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Process_(computing)&quot;&gt;&lt;em&gt;processes&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, and cooperative multitasking in the form of &lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;01_getting_started&#x2F;04_async_await_primer.html&quot;&gt;&lt;em&gt;async&#x2F;await&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in December 2019</title>
                <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2020-01-07/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2020-01-07/</guid>
                <description>&lt;p&gt;Happy New Year!&lt;&#x2F;p&gt;
&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Update &lt;code&gt;x86_64&lt;&#x2F;code&gt; dependency to version 0.8.1. This included the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;701&quot;&gt;dependency update&lt;&#x2F;a&gt; itself, an &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;703&quot;&gt;update of the frame allocation code&lt;&#x2F;a&gt;, and an &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;704&quot;&gt;update of the blog&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;705&quot;&gt;License the &lt;code&gt;blog&#x2F;content&lt;&#x2F;code&gt; folder under CC BY-NC&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;709&quot;&gt;Reword sentence in first post&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pamolloy&quot;&gt;@pamolloy&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Further, we&#x27;re still working on adding &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;692&quot;&gt;Experimental Support for Community Translations&lt;&#x2F;a&gt; to the blog, starting with &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;694&quot;&gt;Simplified Chinese&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;699&quot;&gt;Traditional Chinese&lt;&#x2F;a&gt;. Any help is appreciated!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the bootloader this month.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m currently working on rewriting the 16-bit&#x2F;32-bit stages in Rust and making the bootloader more modular in the process. This should make it much easier to add support for UEFI and GRUB booting later.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool this month.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We landed a number of breaking changes this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;91&quot;&gt;Replace &lt;code&gt;ux&lt;&#x2F;code&gt; dependency with custom wrapper structs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;89&quot;&gt;Add new UnusedPhysFrame type and use it in Mapper::map_to&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;84&quot;&gt;Make Mapper trait object safe by adding &lt;code&gt;Self: Sized&lt;&#x2F;code&gt; bounds on generic functions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;108&quot;&gt;Rename divide_by_zero field of IDT to divide_error&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;109&quot;&gt;Introduce new diverging handler functions for exceptions classified as &amp;quot;abort&amp;quot;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These changes were released an version 0.8.0. Unfortunately, there was a missing re-export for the new &lt;code&gt;UnusedPhysFrame&lt;&#x2F;code&gt; type. We fixed it in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;110&quot;&gt;#110&lt;&#x2F;a&gt; and released the fix as version 0.8.1.&lt;&#x2F;p&gt;
&lt;p&gt;There was one more addition to the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate afterwards:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;111&quot;&gt;Add support for cr4 control register (with complete documentation)&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;KarimAllah&quot;&gt;@KarimAllah&lt;&#x2F;a&gt; (released as version 0.8.2).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There were also a few changes related to continuous integration:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;103&quot;&gt;Remove bors from this repo&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;104&quot;&gt;Run &#x27;push&#x27; builds only for master branch&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;105&quot;&gt;Remove Travis CI and Azure Pipelines scripts&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;100&quot;&gt;Add caching of cargo crates to GitHub Actions CI&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate, which cross-compiles the sysroot, received the following updates this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;43&quot;&gt;Add &lt;code&gt;--quiet&lt;&#x2F;code&gt; flag that suppresses &amp;quot;waiting for file lock&amp;quot; message&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Nils-TUD&quot;&gt;@Nils-TUD&lt;&#x2F;a&gt; (published as version 0.5.19)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;50&quot;&gt;Fix wrong feature name for memcpy=false&lt;&#x2F;a&gt; (released as version 0.5.20)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in October and November 2019</title>
                <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2019-12-02/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2019-12-02/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I moved to a new apartment mid-October and had lots of work to do there, so I didn&#x27;t have the time for creating the October status update post. Therefore, this post lists the changes from both October and November. I&#x27;m slowly picking up speed again, but I still have a lot of mails in my backlog. Sorry if you haven&#x27;t received an answer yet!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The blog itself received only a minor update: &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;687&quot;&gt;Use panic! instead of println! + loop in double fault handler&lt;&#x2F;a&gt;. This fixes an issue where a double fault during &lt;code&gt;cargo xtest&lt;&#x2F;code&gt; leads to an endless loop without any output on the serial port.&lt;&#x2F;p&gt;
&lt;p&gt;We also have other news: We plan to add &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;692&quot;&gt;Experimental Support for Community Translations&lt;&#x2F;a&gt; to the blog. While this imposes additional challenges, it makes the content accessible to people who don&#x27;t speak English, so it&#x27;s definitely worth trying in my opinion. The first additional language will be &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;694&quot;&gt;Chinese&lt;&#x2F;a&gt;, based on an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rustcc&#x2F;writing-an-os-in-rust&quot;&gt;existing translation&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;luojia65&quot;&gt;@luojia65&lt;&#x2F;a&gt;. Many thanks also to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TheBegining&quot;&gt;@TheBegining&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rustin-Liu&quot;&gt;@Rustin-Liu&lt;&#x2F;a&gt; for helping with the translation!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;81&quot;&gt;Change the way the kernel entry point is called to honor alignement ABI&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;GuillaumeDIDIER&quot;&gt;@GuillaumeDIDIER&lt;&#x2F;a&gt; (published as version 0.8.2)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;82&quot;&gt;Add support for Github Actions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;85&quot;&gt;Remove unnecessary &lt;code&gt;extern C&lt;&#x2F;code&gt; on panic handler to fix not-ffi-safe warning&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cmsd2&quot;&gt;@cmsd2&lt;&#x2F;a&gt; (published as version 0.8.3)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;47&quot;&gt;Don&#x27;t exit with expected exit code when failed to read QEMU exit code&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;93&quot;&gt;Switch to GitHub Actions for CI&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;94&quot;&gt;Use &lt;code&gt;repr C&lt;&#x2F;code&gt; to suppress not-ffi-safe when used with extern handler functions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cmsd2&quot;&gt;@cmsd2&lt;&#x2F;a&gt; (published as version 0.7.6)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;95&quot;&gt;Add &lt;code&gt;slice&lt;&#x2F;code&gt; and &lt;code&gt;slice_mut&lt;&#x2F;code&gt; methods to IDT&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foxcob&quot;&gt;@foxcob&lt;&#x2F;a&gt; (published as version 0.7.7)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;47&quot;&gt;Add support for publishing and installing cross compiled crates&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ALSchwalm&quot;&gt;@ALSchwalm&lt;&#x2F;a&gt; (published as version 0.5.18)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in September 2019</title>
                <pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2019-10-06/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2019-10-06/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I finished my master thesis and got my degree this month, so I only had limited time for my open source work. I still managed to perform a few minor updates, including code simplications for the &lt;em&gt;Paging Implementation&lt;&#x2F;em&gt; post and the evaluation of GitHub Actions as a CI service.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;666&quot;&gt;Improve Paging Implementation Post&lt;&#x2F;a&gt;: Improves and simplifies the code in multiple places&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;660&quot;&gt;Use GitHub Actions to build and deploy blog&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Set up GitHub Actions for &lt;code&gt;post-XX&lt;&#x2F;code&gt; branches: &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;661&quot;&gt;&lt;code&gt;post-01&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;662&quot;&gt;&lt;code&gt;post-02&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;663&quot;&gt;&lt;code&gt;post-04&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;664&quot;&gt;Update to bootloader 0.8.0&lt;&#x2F;a&gt;: Considerably reduces compile times&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;670&quot;&gt;Update to Zola 0.9.0&lt;&#x2F;a&gt;: Updates the used static site generator to the latest version&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;44&quot;&gt;Print a warning when building for the host target&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;77&quot;&gt;Add a Cargo Feature for Enabling SSE&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;uart-16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;1&quot;&gt;Update to x86_64 0.7.3 and bitflags&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;2&quot;&gt;Document how serial port is configured by default&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;edigaryev&quot;&gt;@edigaryev&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;No updates were merged in September. However, I&#x27;m planning some breaking changes for the crate, namely:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;91&quot;&gt;Replace &lt;code&gt;ux&lt;&#x2F;code&gt; dependency with custom wrapper structs&lt;&#x2F;a&gt; to reduce compile times&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;89&quot;&gt;Add new UnsafePhysFrame type and use it in Mapper::map_to&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;84&quot;&gt;Make Mapper trait object safe by adding &lt;code&gt;Self: Sized&lt;&#x2F;code&gt; bounds on generic functions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!--
## `bootimage`

No updates were merged in September.
--&gt;
</description>
            </item>
        
            <item>
                <title>Updates in August 2019</title>
                <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2019-09-09/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2019-09-09/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I was very busy with finishing my master&#x27;s thesis, so I didn&#x27;t have any to implement any notable changes myself. Thanks to contributions by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;, we were still able to publish new versions of the &lt;code&gt;x86_64&lt;&#x2F;code&gt;, &lt;code&gt;bootimage&lt;&#x2F;code&gt; and &lt;code&gt;bootloader&lt;&#x2F;code&gt; crates.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Apart from &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;650&quot;&gt;rewriting the section about no-harness tests&lt;&#x2F;a&gt; of the &lt;em&gt;Testing&lt;&#x2F;em&gt; post, there were no notable changes to the blog in August. Now that I have some more free time again, I plan to upgrade the blog to the latest versions of &lt;code&gt;bootloader&lt;&#x2F;code&gt; and &lt;code&gt;bootimage&lt;&#x2F;code&gt;, evaluate the use of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;features&#x2F;actions&quot;&gt;GitHub Actions&lt;&#x2F;a&gt; for the repository, and continue the work on the upcoming post about heap allocator implementations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt;, the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate now has &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;87&quot;&gt;support for the &lt;code&gt;FsBase&lt;&#x2F;code&gt; and &lt;code&gt;GsBase&lt;&#x2F;code&gt; registers&lt;&#x2F;a&gt;. The change was published as version 0.7.5.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To allow bootloaders to read configuration from the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; file of the kernel, the &lt;code&gt;bootimage&lt;&#x2F;code&gt; crate now &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;45&quot;&gt;passes the location of the kernel&#x27;s Cargo.toml to bootloader crates&lt;&#x2F;a&gt;. This change was implemented by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; and published as version 0.7.7.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Apart from initializing the CPU and loading the kernel, the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate is also responsible for creating several memory regions for the kernel, for example a program stack and the boot information struct. These regions must be mapped at some address in the virtual address space.&lt;&#x2F;p&gt;
&lt;p&gt;As a stop-gap solution, the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate used fixed virtual addresses for these regions, which resulted in errors if the kernel tried to use the same address ranges itself. For example, the (optional) recursive mapping of page tables often conflicted with so-called &lt;em&gt;higher half kernels&lt;&#x2F;em&gt;, which live at the upper end of the address space. To avoid these conflicts, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; updated the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;71&quot;&gt;dynamically map the kernel stack, boot info, physical memory, and recursive table regions&lt;&#x2F;a&gt; at an unused virtual address range.&lt;&#x2F;p&gt;
&lt;p&gt;To also support specifying explicit addresses for these regions, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; further added support for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;73&quot;&gt;parsing bootloader configuration from the kernel&#x27;s Cargo.toml&lt;&#x2F;a&gt;. This way, the virtual addresses of the kernel stack and physical memory mapping can now be configured using a &lt;code&gt;package.metadata.bootloader&lt;&#x2F;code&gt; key in the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; of the kernel. In a third pull request, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; also made the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;72&quot;&gt;kernel stack size configurable&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The changes were published together as version 0.8.0. This is a breaking update because the new configuration system requires at least version 0.7.7 of &lt;code&gt;bootimage&lt;&#x2F;code&gt;, which is the first version that passes the location of the kernel&#x27;s &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in July 2019</title>
                <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2019-08-02/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2019-08-02/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;Since I&#x27;m still very busy with my master thesis, I haven&#x27;t had the time to work on a new post. But there were quite a few maintenance updates this month and also a few new features such as the new &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt; type in the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;p&gt;We also had some great contributions this month. Thanks to the efforts of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;, we were able to considerably lower the compile times of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; and &lt;code&gt;bootloader&lt;&#x2F;code&gt; crates. Thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2F;a&gt;, the &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate now has a  &lt;code&gt;cargo xdoc&lt;&#x2F;code&gt; subcommands and support for the &lt;code&gt;cargo {c, b, t, r}&lt;&#x2F;code&gt; aliases.&lt;&#x2F;p&gt;
&lt;p&gt;The following list gives a short overview of notable changes to the different projects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;blog_os&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;638&quot;&gt;Fix a lot of dead links in both the second and first edition&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;644&quot;&gt;Update paging introduction post to use page fault error code&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;82&quot;&gt;Reexport MappedPageTable on non-x86_64 platforms too&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;78&quot;&gt;Update GDT docs, add user_data_segment function and WRITABLE flag&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; (published as version 0.7.2)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;83&quot;&gt;Add a new &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt; mapper type&lt;&#x2F;a&gt; (published as version 0.7.3)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;86&quot;&gt;Update integration tests to use new testing framework&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;85&quot;&gt;Remove raw-cpuid dependency and use rdrand intrinsics&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; (published as version 0.7.4)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;62&quot;&gt;Remove stabilized publish-lockfile feature&lt;&#x2F;a&gt; (published as version 0.6.2)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;63&quot;&gt;Update CI badge, use latest version of x86_64 crate and rustfmt&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; (published as version 0.6.3)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;67&quot;&gt;Use volatile accesses in VGA code and make font dependency optional&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Making the dependency optional should improve compile times when the VGA text mode is used&lt;&#x2F;li&gt;
&lt;li&gt;Published as version 0.6.4&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Breaking&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;68&quot;&gt;Only include dependencies when &lt;code&gt;binary&lt;&#x2F;code&gt; feature is enabled&lt;&#x2F;a&gt; (published as version 0.7.0)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;bootimage&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;43&quot;&gt;If the bootloader has a feature named &lt;code&gt;binary&lt;&#x2F;code&gt;, enable it&lt;&#x2F;a&gt; (published as version 0.7.6)
&lt;ul&gt;
&lt;li&gt;This is required for building &lt;code&gt;bootloader 0.7.0&lt;&#x2F;code&gt; or later&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;cargo-xbuild&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;39&quot;&gt;Add &lt;code&gt;cargo xdoc&lt;&#x2F;code&gt; command for invoking &lt;code&gt;cargo doc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2F;a&gt; (published as version 0.5.13)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;40&quot;&gt;Don&#x27;t append a &lt;code&gt;--sysroot&lt;&#x2F;code&gt; argument to &lt;code&gt;RUSTFLAGS&lt;&#x2F;code&gt; if it already contains one&lt;&#x2F;a&gt; (published as version 0.5.14)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;42&quot;&gt;Add xb, xt, xc, and xr subcommands&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2F;a&gt; (published as version 0.5.15)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in June 2019</title>
                <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2019-07-06/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2019-07-06/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;My focus this month was to finish the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;heap-allocation&#x2F;&quot;&gt;&lt;em&gt;Heap Allocation&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, on which I had been working since March. I originally wanted to include a section about different allocator designs (bump, linked list, slab, …) and how to implement them, but I decided to split it out into a separate post because it became much too long. I try to release this half-done post soon.&lt;&#x2F;p&gt;
&lt;p&gt;Apart from the new post, there were some minor updates to the &lt;code&gt;x86_64&lt;&#x2F;code&gt;, &lt;code&gt;bootloader&lt;&#x2F;code&gt; and &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crates. The following gives a short overview of notable changes to the different projects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;blog_os&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;617&quot;&gt;Use misspell tool to look for common typos&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;625&quot;&gt;New post about heap allocation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;77&quot;&gt;Add ring-3 flag to GDT descriptor&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mark-i-m&quot;&gt;@mark-i-m&lt;&#x2F;a&gt; (released as version 0.7.1)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;79&quot;&gt;Add bochs magic breakpoint, read instruction pointer, inline instructions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;58&quot;&gt;Make the physical memory offset configurable through a &lt;code&gt;BOOTLOADER_PHYSICAL_MEMORY_OFFSET&lt;&#x2F;code&gt; environment variable&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;59&quot;&gt;Use a stripped copy of the kernel binary (debug info removed) to reduce load times&lt;&#x2F;a&gt; (released as version 0.6.1)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!-- ## Bootimage --&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;cargo-xbuild&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;commit&#x2F;994b5e75e1a4062cf506700e0ff38d5404338a37&quot;&gt;Document the XBUILD_SYSROOT_PATH environment variable&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;commit&#x2F;a1ff03311dd74447e8e845b4b96f2e137850027d&quot;&gt;Fix incorrect joining of paths that caused some problems on Windows&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Heap Allocation</title>
                <pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/heap-allocation/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/heap-allocation/</guid>
                <description>&lt;p&gt;This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents common allocation errors. It then implements the basic allocation interface of Rust, creates a heap memory region, and sets up an allocator crate. At the end of this post all the allocation and collection types of the built-in &lt;code&gt;alloc&lt;&#x2F;code&gt; crate will be available to our kernel.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;heap-allocation&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-10&quot;&gt;&lt;code&gt;post-10&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;local-and-static-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#local-and-static-variables&quot; aria-label=&quot;Anchor link for: local-and-static-variables&quot;&gt;🔗&lt;&#x2F;a&gt;Local and Static Variables&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;local-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#local-variables&quot; aria-label=&quot;Anchor link for: local-variables&quot;&gt;🔗&lt;&#x2F;a&gt;Local Variables&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;static-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#static-variables&quot; aria-label=&quot;Anchor link for: static-variables&quot;&gt;🔗&lt;&#x2F;a&gt;Static Variables&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;dynamic-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dynamic-memory&quot; aria-label=&quot;Anchor link for: dynamic-memory&quot;&gt;🔗&lt;&#x2F;a&gt;Dynamic Memory&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;common-errors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#common-errors&quot; aria-label=&quot;Anchor link for: common-errors&quot;&gt;🔗&lt;&#x2F;a&gt;Common Errors&lt;&#x2F;h3&gt;
&lt;p&gt;Apart from memory leaks, which are unfortunate but don&#x27;t make the program vulnerable to attackers, there are two common types of bugs with more severe consequences:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;When we accidentally continue to use a variable after calling &lt;code&gt;deallocate&lt;&#x2F;code&gt; on it, we have a so-called &lt;strong&gt;use-after-free&lt;&#x2F;strong&gt; vulnerability. Such a bug causes undefined behavior and can often be exploited by attackers to execute arbitrary code.&lt;&#x2F;li&gt;
&lt;li&gt;When we accidentally free a variable twice, we have a &lt;strong&gt;double-free&lt;&#x2F;strong&gt; vulnerability. This is problematic because it might free a different allocation that was allocated in the same spot after the first &lt;code&gt;deallocate&lt;&#x2F;code&gt; call. Thus, it can lead to an use-after-free vulnerability again.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These types of vulnerabilities are commonly known, so one might expect that people learned how to avoid them by now. But no, such vulnerabilities are still regularly found, for example this recent &lt;a href=&quot;https:&#x2F;&#x2F;securityboulevard.com&#x2F;2019&#x2F;02&#x2F;linux-use-after-free-vulnerability-found-in-linux-2-6-through-4-20-11&#x2F;&quot;&gt;use-after-free vulnerability in Linux&lt;&#x2F;a&gt; that allowed arbitrary code execution. This shows that even the best programmers are not always able to correctly handle dynamic memory in complex projects.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid these issues, many languages such as Java or Python manage dynamic memory automatically using a technique called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Garbage_collection_(computer_science)&quot;&gt;&lt;em&gt;garbage collection&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. The idea is that the programmer never invokes &lt;code&gt;deallocate&lt;&#x2F;code&gt; manually. Instead, the program is regularly paused and scanned for unused heap variables, which are then automatically deallocated. Thus, the above vulnerabilities can never occur. The drawbacks are the performance overhead of the regular scan and the probably long pause times.&lt;&#x2F;p&gt;
&lt;p&gt;Rust takes a different approach to the problem: It uses a concept called &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-01-what-is-ownership.html&quot;&gt;&lt;em&gt;ownership&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; that is able to check the correctness of dynamic memory operations at compile time. Thus no garbage collection is needed to avoid the mentioned vulnerabilities, which means that there is no performance overhead. Another advantage of this approach is that the programmer still has fine-grained control over the use of dynamic memory, just like with C or C++.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocations-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocations-in-rust&quot; aria-label=&quot;Anchor link for: allocations-in-rust&quot;&gt;🔗&lt;&#x2F;a&gt;Allocations in Rust&lt;&#x2F;h3&gt;
&lt;p&gt;Instead of letting the programmer manually call &lt;code&gt;allocate&lt;&#x2F;code&gt; and &lt;code&gt;deallocate&lt;&#x2F;code&gt;, the Rust standard library provides abstraction types that call these functions implicitly. The most important type is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;boxed&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, which is an abstraction for a heap-allocated value. It provides a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.new&quot;&gt;&lt;code&gt;Box::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; constructor function that takes a value, calls &lt;code&gt;allocate&lt;&#x2F;code&gt; with the size of the value, and then moves the value to the newly allocated slot on the heap. To free the heap memory again, the &lt;code&gt;Box&lt;&#x2F;code&gt; type implements the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-03-drop.html&quot;&gt;&lt;code&gt;Drop&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt; to call &lt;code&gt;deallocate&lt;&#x2F;code&gt; when it goes out of scope:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; z = Box::new([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]);
    […]
} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; z goes out of scope and `deallocate` is called
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This pattern has the strange name &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Resource_acquisition_is_initialization&quot;&gt;&lt;em&gt;resource acquisition is initialization&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; (or &lt;em&gt;RAII&lt;&#x2F;em&gt; for short). It originated in C++, where it is used to implement a similar abstraction type called &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Such a type alone does not suffice to prevent all use-after-free bugs since programmers can still hold on to references after the &lt;code&gt;Box&lt;&#x2F;code&gt; goes out of scope and the corresponding heap memory slot is deallocated:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x = {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; z = Box::new([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;z[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
}; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; z goes out of scope and `deallocate` is called
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, x);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is where Rust&#x27;s ownership comes in. It assigns an abstract &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-03-lifetime-syntax.html&quot;&gt;lifetime&lt;&#x2F;a&gt; to each reference, which is the scope in which the reference is valid. In the above example, the &lt;code&gt;x&lt;&#x2F;code&gt; reference is taken from the &lt;code&gt;z&lt;&#x2F;code&gt; array, so it becomes invalid after &lt;code&gt;z&lt;&#x2F;code&gt; goes out of scope. When you &lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=28180d8de7b62c6b4a681a7b1f745a48&quot;&gt;run the above example on the playground&lt;&#x2F;a&gt; you see that the Rust compiler indeed throws an error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0597]: `z[_]` does not live long enough
 --&amp;gt; src&#x2F;main.rs:4:9
  |
2 |     let x = {
  |         - borrow later stored here
3 |         let z = Box::new([1,2,3]);
4 |         &amp;amp;z[1]
  |         ^^^^^ borrowed value does not live long enough
5 |     }; &#x2F;&#x2F; z goes out of scope and `deallocate` is called
  |     - `z[_]` dropped here while still borrowed
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The terminology can be a bit confusing at first. Taking a reference to a value is called &lt;em&gt;borrowing&lt;&#x2F;em&gt; the value since it&#x27;s similar to a borrow in real life: You have temporary access to an object but need to return it sometime and you must not destroy it. By checking that all borrows end before an object is destroyed, the Rust compiler can guarantee that no use-after-free situation can occur.&lt;&#x2F;p&gt;
&lt;p&gt;Rust&#x27;s ownership system goes even further and does not only prevent use-after-free bugs, but provides complete &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety&quot;&gt;&lt;em&gt;memory safety&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; like garbage collected languages like Java or Python do. Additionally, it guarantees &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_safety&quot;&gt;&lt;em&gt;thread safety&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and is thus even safer than those languages in multi-threaded code. And most importantly, all these checks happen at compile time, so there is no runtime overhead compared to hand written memory management in C.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;use-cases&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#use-cases&quot; aria-label=&quot;Anchor link for: use-cases&quot;&gt;🔗&lt;&#x2F;a&gt;Use Cases&lt;&#x2F;h3&gt;
&lt;p&gt;We now know the basics of dynamic memory allocation in Rust, but when should we use it? We&#x27;ve come really far with our kernel without dynamic memory allocation, so why do we need it now?&lt;&#x2F;p&gt;
&lt;p&gt;First, dynamic memory allocation always comes with a bit of performance overhead, since we need to find a free slot on the heap for every allocation. For this reason local variables are generally preferable, especially in performance sensitive kernel code. However, there are cases where dynamic memory allocation is the best choice.&lt;&#x2F;p&gt;
&lt;p&gt;As a basic rule, dynamic memory is required for variables that have a dynamic lifetime or a variable size. The most important type with a dynamic lifetime is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;rc&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Rc&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, which counts the references to its wrapped value and deallocates it after all references went out of scope. Examples for types with a variable size are &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;vec&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Vec&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;string&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, and other &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;index.html&quot;&gt;collection types&lt;&#x2F;a&gt; that dynamically grow when more elements are added. These types work by allocating a larger amount of memory when they become full, copying all elements over, and then deallocating the old allocation.&lt;&#x2F;p&gt;
&lt;p&gt;For our kernel we will mostly need the collection types, for example for storing a list of active tasks when implementing multitasking in future posts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-allocator-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator-interface&quot; aria-label=&quot;Anchor link for: the-allocator-interface&quot;&gt;🔗&lt;&#x2F;a&gt;The Allocator Interface&lt;&#x2F;h2&gt;
&lt;p&gt;The first step in implementing a heap allocator is to add a dependency on the built-in &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. Like the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;&quot;&gt;&lt;code&gt;core&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, it is a subset of the standard library that additionally contains the allocation and collection types. To add the dependency on &lt;code&gt;alloc&lt;&#x2F;code&gt;, we add the following to our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Contrary to normal dependencies, we don&#x27;t need to modify the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;. The reason is that the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate ships with the Rust compiler as part of the standard library, so the compiler already knows about the crate. By adding this &lt;code&gt;extern crate&lt;&#x2F;code&gt; statement, we specify that the compiler should try to include it. (Historically, all dependencies needed an &lt;code&gt;extern crate&lt;&#x2F;code&gt; statement, which is now optional).&lt;&#x2F;p&gt;
&lt;p&gt;Since we are compiling for a custom target, we can&#x27;t use the precompiled version of &lt;code&gt;alloc&lt;&#x2F;code&gt; that is shipped with the Rust installation. Instead, we have to tell cargo to recompile the crate from source. We can do that, by adding it to the &lt;code&gt;unstable.build-std&lt;&#x2F;code&gt; array in our &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt; file:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2F;config.toml

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;unstable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;build-std &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;core&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;compiler_builtins&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;alloc&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the compiler will recompile and include the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate in our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;The reason that the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate is disabled by default in &lt;code&gt;#[no_std]&lt;&#x2F;code&gt; crates is that it has additional requirements. We can see these requirements as errors when we try to compile our project now:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: no global memory allocator found but one is required; link to std or add
       #[global_allocator] to a static item that implements the GlobalAlloc trait.

error: `#[alloc_error_handler]` function required, but not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first error occurs because the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate requires an heap allocator, which is an object that provides the &lt;code&gt;allocate&lt;&#x2F;code&gt; and &lt;code&gt;deallocate&lt;&#x2F;code&gt; functions. In Rust, heap allocators are described by the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, which is mentioned in the error message. To set the heap allocator for the crate, the &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; attribute must be applied to a &lt;code&gt;static&lt;&#x2F;code&gt; variable that implements the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;p&gt;The second error occurs because calls to &lt;code&gt;allocate&lt;&#x2F;code&gt; can fail, most commonly when there is no more memory available. Our program must be able to react to this case, which is what the &lt;code&gt;#[alloc_error_handler]&lt;&#x2F;code&gt; function is for.&lt;&#x2F;p&gt;
&lt;p&gt;We will describe these traits and attributes in detail in the following sections.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-globalalloc-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-globalalloc-trait&quot; aria-label=&quot;Anchor link for: the-globalalloc-trait&quot;&gt;🔗&lt;&#x2F;a&gt;The &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait defines the functions that a heap allocator must provide. The trait is special because it is almost never used directly by the programmer. Instead, the compiler will automatically insert the appropriate calls to the trait methods when using the allocation and collection types of &lt;code&gt;alloc&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Since we will need to implement the trait for all our allocator types, it is worth taking a closer look at its declaration:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;GlobalAlloc {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout: Layout);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc_zeroed(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;realloc(
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
        ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        layout: Layout,
        new_size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It defines the two required methods &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#tymethod.dealloc&quot;&gt;&lt;code&gt;dealloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which correspond to the &lt;code&gt;allocate&lt;&#x2F;code&gt; and &lt;code&gt;deallocate&lt;&#x2F;code&gt; functions we used in our examples:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method takes a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;struct.Layout.html&quot;&gt;&lt;code&gt;Layout&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance as argument, which describes the desired size and alignment that the allocated memory should have. It returns a [raw pointer] to the first byte of the allocated memory block. Instead of an explicit error value, the &lt;code&gt;alloc&lt;&#x2F;code&gt; method returns a null pointer to signal an allocation error. This is a bit non-idiomatic, but it has the advantage that wrapping existing system allocators is easy, since they use the same convention.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#tymethod.dealloc&quot;&gt;&lt;code&gt;dealloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method is the counterpart and responsible for freeing a memory block again. It receives two arguments, the pointer returned by &lt;code&gt;alloc&lt;&#x2F;code&gt; and the &lt;code&gt;Layout&lt;&#x2F;code&gt; that was used for the allocation.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The trait additionally defines the two methods &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.alloc_zeroed&quot;&gt;&lt;code&gt;alloc_zeroed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.realloc&quot;&gt;&lt;code&gt;realloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with default implementations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.alloc_zeroed&quot;&gt;&lt;code&gt;alloc_zeroed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method is equivalent to calling &lt;code&gt;alloc&lt;&#x2F;code&gt; and then setting the allocated memory block to zero, which is exactly what the provided default implementation does. An allocator implementation can override the default implementations with a more efficient custom implementation if possible.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.realloc&quot;&gt;&lt;code&gt;realloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method allows to grow or shrink an allocation. The default implementation allocates a new memory block with the desired size and copies over all the content from the previous allocation. Again, an allocator implementation can probably provide a more efficient implementation of this method, for example by growing&#x2F;shrinking the allocation in-place if possible.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;unsafety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unsafety&quot; aria-label=&quot;Anchor link for: unsafety&quot;&gt;🔗&lt;&#x2F;a&gt;Unsafety&lt;&#x2F;h4&gt;
&lt;p&gt;One thing to notice is that both the trait itself and all trait methods are declared as &lt;code&gt;unsafe&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The reason for declaring the trait as &lt;code&gt;unsafe&lt;&#x2F;code&gt; is that the programmer must guarantee that the trait implementation for an allocator type is correct. For example, the &lt;code&gt;alloc&lt;&#x2F;code&gt; method must never return a memory block that is already used somewhere else because this would cause undefined behavior.&lt;&#x2F;li&gt;
&lt;li&gt;Similarly, the reason that the methods are &lt;code&gt;unsafe&lt;&#x2F;code&gt; is that the caller must ensure various invariants when calling the methods, for example that the &lt;code&gt;Layout&lt;&#x2F;code&gt; passed to &lt;code&gt;alloc&lt;&#x2F;code&gt; specifies a non-zero size. This is not really relevant in practice since the methods are normally called directly by the compiler, which ensures that the requirements are met.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;a-dummyallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-dummyallocator&quot; aria-label=&quot;Anchor link for: a-dummyallocator&quot;&gt;🔗&lt;&#x2F;a&gt;A &lt;code&gt;DummyAllocator&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we know what an allocator type should provide, we can create a simple dummy allocator. For that we create a new &lt;code&gt;allocator&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocator;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our dummy allocator does the absolute minimum to implement the trait and always return an error when &lt;code&gt;alloc&lt;&#x2F;code&gt; is called. It looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::alloc::{GlobalAlloc, Layout};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ptr::null_mut;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Dummy;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;GlobalAlloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Dummy {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, _layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        null_mut()
    }

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, _ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, _layout: Layout) {
        panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;dealloc should be never called&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The struct does not need any fields, so we create it as a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero sized type&lt;&#x2F;a&gt;. As mentioned above, we always return the null pointer from &lt;code&gt;alloc&lt;&#x2F;code&gt;, which corresponds to an allocation error. Since the allocator never returns any memory, a call to &lt;code&gt;dealloc&lt;&#x2F;code&gt; should never occur. For this reason we simply panic in the &lt;code&gt;dealloc&lt;&#x2F;code&gt; method. The &lt;code&gt;alloc_zeroed&lt;&#x2F;code&gt; and &lt;code&gt;realloc&lt;&#x2F;code&gt; methods have default implementations, so we don&#x27;t need to provide implementations for them.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a simple allocator, but we still have to tell the Rust compiler that it should use this allocator. This is where the &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; attribute comes in.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-global-allocator-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-allocator-attribute&quot; aria-label=&quot;Anchor link for: the-global-allocator-attribute&quot;&gt;🔗&lt;&#x2F;a&gt;The &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; Attribute&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; attribute tells the Rust compiler which allocator instance it should use as the global heap allocator. The attribute is only applicable to a &lt;code&gt;static&lt;&#x2F;code&gt; that implements the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait. Let&#x27;s register an instance of our &lt;code&gt;Dummy&lt;&#x2F;code&gt; allocator as the global allocator:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Dummy = Dummy;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the &lt;code&gt;Dummy&lt;&#x2F;code&gt; allocator is a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero sized type&lt;&#x2F;a&gt;, we don&#x27;t need to specify any fields in the initialization expression.&lt;&#x2F;p&gt;
&lt;p&gt;When we now try to compile it, the first error should be gone. Let&#x27;s fix the remaining second error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: `#[alloc_error_handler]` function required, but not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;the-alloc-error-handler-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-alloc-error-handler-attribute&quot; aria-label=&quot;Anchor link for: the-alloc-error-handler-attribute&quot;&gt;🔗&lt;&#x2F;a&gt;The &lt;code&gt;#[alloc_error_handler]&lt;&#x2F;code&gt; Attribute&lt;&#x2F;h3&gt;
&lt;p&gt;As we learned when discussing the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait, the &lt;code&gt;alloc&lt;&#x2F;code&gt; function can signal an allocation error by returning a null pointer. The question is: how should the Rust runtime react to such an allocation failure? This is where the &lt;code&gt;#[alloc_error_handler]&lt;&#x2F;code&gt; attribute comes in. It specifies a function that is called when an allocation error occurs, similar to how our panic handler is called when a panic occurs.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s add such a function to fix the compilation error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![feature(alloc_error_handler)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; at the top of the file

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[alloc_error_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc_error_handler(layout: alloc::alloc::Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;allocation error: {:?}&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout)
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;alloc_error_handler&lt;&#x2F;code&gt; function is still unstable, so we need a feature gate to enable it. The function receives a single argument: the &lt;code&gt;Layout&lt;&#x2F;code&gt; instance that was passed to &lt;code&gt;alloc&lt;&#x2F;code&gt; when the allocation failure occurred. There&#x27;s nothing we can do to resolve the failure, so we just panic with a message that contains the &lt;code&gt;Layout&lt;&#x2F;code&gt; instance.&lt;&#x2F;p&gt;
&lt;p&gt;With this function, the compilation errors should be fixed. Now we can use the allocation and collection types of &lt;code&gt;alloc&lt;&#x2F;code&gt;, for example we can use a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to allocate a value on the heap:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::boxed::Box;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; […] print &amp;quot;Hello World!&amp;quot;, call `init`, create `mapper` and `frame_allocator`

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; […] call `test_main` in test mode

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}

&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we need to specify the &lt;code&gt;extern crate alloc&lt;&#x2F;code&gt; statement in our &lt;code&gt;main.rs&lt;&#x2F;code&gt; too. This is required because the &lt;code&gt;lib.rs&lt;&#x2F;code&gt; and &lt;code&gt;main.rs&lt;&#x2F;code&gt; part are treated as separate crates. However, we don&#x27;t need to create another &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; static because the global allocator applies to all crates in the project. In fact, specifying an additional allocator in another crate would be an error.&lt;&#x2F;p&gt;
&lt;p&gt;When we run the above code, we see that our &lt;code&gt;alloc_error_handler&lt;&#x2F;code&gt; function is called:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;heap-allocation&#x2F;qemu-dummy-output.png&quot; alt=&quot;QEMU printing &amp;quot;panicked at `allocation error: Layout { size_: 4, align_: 4 }, src&#x2F;lib.rs:89:5&amp;quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The error handler is called because the &lt;code&gt;Box::new&lt;&#x2F;code&gt; function implicitly calls the &lt;code&gt;alloc&lt;&#x2F;code&gt; function of the global allocator. Our dummy allocator always returns a null pointer, so every allocation fails. To fix this we need to create an allocator that actually returns usable memory.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-kernel-heap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-kernel-heap&quot; aria-label=&quot;Anchor link for: creating-a-kernel-heap&quot;&gt;🔗&lt;&#x2F;a&gt;Creating a Kernel Heap&lt;&#x2F;h2&gt;
&lt;p&gt;Before we can create a proper allocator, we first need to create a heap memory region from which the allocator can allocate memory. To do this, we need to define a virtual memory range for the heap region and then map this region to physical frames. See the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;memory-classes&#x2F;&quot;&gt;&lt;em&gt;&amp;quot;Introduction To Paging&amp;quot;&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post for an overview of virtual memory and page tables.&lt;&#x2F;p&gt;
&lt;p&gt;The first step is to define a virtual memory region for the heap. We can choose any virtual address range that we like, as long as it is not already used for a different memory region. Let&#x27;s define it as the memory starting at address &lt;code&gt;0x_4444_4444_0000&lt;&#x2F;code&gt; so that we can easily recognize a heap pointer later:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x_4444_4444_0000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; 100 KiB
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We set the heap size to 100 KiB for now. If we need more space in the future, we can simply increase it.&lt;&#x2F;p&gt;
&lt;p&gt;If we tried to use this heap region now, a page fault would occur since the virtual memory region is not mapped to physical memory yet. To resolve this, we create an &lt;code&gt;init_heap&lt;&#x2F;code&gt; function that maps the heap pages using the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;allocators&#x2F;&quot;&gt;&lt;code&gt;Mapper&lt;&#x2F;code&gt; API&lt;&#x2F;a&gt; that we introduced in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;allocators&#x2F;&quot;&gt;&lt;em&gt;&amp;quot;Paging Implementation&amp;quot;&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{
    structures::paging::{
        mapper::MapToError, FrameAllocator, Mapper, Page, PageTableFlags, Size4KiB,
    },
    VirtAddr,
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_heap(
    mapper: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl Mapper&amp;lt;Size4KiB&amp;gt;,
    frame_allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
) -&amp;gt; Result&amp;lt;(), MapToError&amp;lt;Size4KiB&amp;gt;&amp;gt; {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_range = {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_start = VirtAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_end = heap_start + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_start_page = Page::containing_address(heap_start);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_end_page = Page::containing_address(heap_end);
        Page::range_inclusive(heap_start_page, heap_end_page)
    };

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_range {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame = frame_allocator
            .allocate_frame()
            .ok_or(MapToError::FrameAllocationFailed)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags = PageTableFlags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageTableFlags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            mapper.map_to(page, frame, flags, frame_allocator)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.flush()
        };
    }

    Ok(())
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function takes mutable references to a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;trait.FrameAllocator.html&quot;&gt;&lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance, both limited to 4KiB pages by using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;enum.Size4KiB.html&quot;&gt;&lt;code&gt;Size4KiB&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as generic parameter. The return value of the function is a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with the unit type &lt;code&gt;()&lt;&#x2F;code&gt; as success variant and a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;enum.MapToError.html&quot;&gt;&lt;code&gt;MapToError&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as error variant, which is the error type returned by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;Mapper::map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. Reusing the error type makes sense here because the &lt;code&gt;map_to&lt;&#x2F;code&gt; method is the main source of errors in this function.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation can be broken down into two parts:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Creating the page range:&lt;&#x2F;strong&gt;: To create a range of the pages that we want to map, we convert the &lt;code&gt;HEAP_START&lt;&#x2F;code&gt; pointer to a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;addr&#x2F;struct.VirtAddr.html&quot;&gt;&lt;code&gt;VirtAddr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type. Then we calculate the heap end address from it by adding the &lt;code&gt;HEAP_SIZE&lt;&#x2F;code&gt;. We want an inclusive bound (the address of the last byte of the heap), so we subtract 1. Next, we convert the addresses into &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;struct.Page.html&quot;&gt;&lt;code&gt;Page&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; types using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;struct.Page.html#method.containing_address&quot;&gt;&lt;code&gt;containing_address&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function. Finally, we create a page range from the start and end pages using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;struct.Page.html#method.range_inclusive&quot;&gt;&lt;code&gt;Page::range_inclusive&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mapping the pages:&lt;&#x2F;strong&gt; The second step is to map all pages of the page range we just created. For that we iterate over the pages in that range using a &lt;code&gt;for&lt;&#x2F;code&gt; loop. For each page, we do the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We allocate a physical frame that the page should be mapped to using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;trait.FrameAllocator.html#tymethod.allocate_frame&quot;&gt;&lt;code&gt;FrameAllocator::allocate_frame&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. This method returns &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; when there are no more frames left. We deal with that case by mapping it to a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;enum.MapToError.html#variant.FrameAllocationFailed&quot;&gt;&lt;code&gt;MapToError::FrameAllocationFailed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; error through the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.ok_or&quot;&gt;&lt;code&gt;Option::ok_or&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method and then apply the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;edition-guide&#x2F;rust-2018&#x2F;error-handling-and-panics&#x2F;the-question-mark-operator-for-easier-error-handling.html&quot;&gt;question mark operator&lt;&#x2F;a&gt; to return early in the case of an error.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;We set the required &lt;code&gt;PRESENT&lt;&#x2F;code&gt; flag and the &lt;code&gt;WRITABLE&lt;&#x2F;code&gt; flag for the page. With these flags both read and write accesses are allowed, which makes sense for heap memory.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;Mapper::map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method for creating the mapping in the active page table. The method can fail, therefore we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;edition-guide&#x2F;rust-2018&#x2F;error-handling-and-panics&#x2F;the-question-mark-operator-for-easier-error-handling.html&quot;&gt;question mark operator&lt;&#x2F;a&gt; again to forward the error to the caller. On success, the method returns a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html&quot;&gt;&lt;code&gt;MapperFlush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance that we can use to update the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;memory-classes&#x2F;&quot;&gt;&lt;em&gt;translation lookaside buffer&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html#method.flush&quot;&gt;&lt;code&gt;flush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The final step is to call this function from our &lt;code&gt;kernel_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::allocator; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new import
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::{self, BootInfoFrameAllocator};

    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::init();

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(phys_mem_offset) };
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        BootInfoFrameAllocator::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;boot_info.memory_map)
    };

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocator::init_heap(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator)
        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap initialization failed&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; […] call `test_main` in test mode

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We show the full function for context here. The only new lines are the &lt;code&gt;blog_os::allocator&lt;&#x2F;code&gt; import and the call to &lt;code&gt;allocator::init_heap&lt;&#x2F;code&gt; function. In case the &lt;code&gt;init_heap&lt;&#x2F;code&gt; function returns an error, we panic using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html#method.expect&quot;&gt;&lt;code&gt;Result::expect&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method since there is currently no sensible way for us to handle this error.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a mapped heap memory region that is ready to be used. The &lt;code&gt;Box::new&lt;&#x2F;code&gt; call still uses our old &lt;code&gt;Dummy&lt;&#x2F;code&gt; allocator, so you will still see the &amp;quot;out of memory&amp;quot; error when you run it. Let&#x27;s fix this by using a proper allocator.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-an-allocator-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-an-allocator-crate&quot; aria-label=&quot;Anchor link for: using-an-allocator-crate&quot;&gt;🔗&lt;&#x2F;a&gt;Using an Allocator Crate&lt;&#x2F;h2&gt;
&lt;p&gt;Since implementing an allocator is somewhat complex, we start by using an external allocator crate. We will learn how to implement our own allocator in the next post.&lt;&#x2F;p&gt;
&lt;p&gt;A simple allocator crate for &lt;code&gt;no_std&lt;&#x2F;code&gt; applications is the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;linked-list-allocator&#x2F;&quot;&gt;&lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. It&#x27;s name comes from the fact that it uses a linked list data structure to keep track of deallocated memory regions. See the next post for a more detailed explanation of this approach.&lt;&#x2F;p&gt;
&lt;p&gt;To use the crate, we first need to add a dependency on it in our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;linked_list_allocator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.9.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we can replace our dummy allocator with the allocator provided by the crate:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;linked_list_allocator::LockedHeap;

#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: LockedHeap = LockedHeap::empty();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The struct is named &lt;code&gt;LockedHeap&lt;&#x2F;code&gt; because it uses the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spinning_top&#x2F;0.1.0&#x2F;spinning_top&#x2F;type.Spinlock.html&quot;&gt;&lt;code&gt;spinning_top::Spinlock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type for synchronization. This is required because multiple threads could access the &lt;code&gt;ALLOCATOR&lt;&#x2F;code&gt; static at the same time. As always when using a spinlock or a mutex, we need to be careful to not accidentally cause a deadlock. This means that we shouldn&#x27;t perform any allocations in interrupt handlers, since they can run at an arbitrary time and might interrupt an in-progress allocation.&lt;&#x2F;p&gt;
&lt;p&gt;Setting the &lt;code&gt;LockedHeap&lt;&#x2F;code&gt; as global allocator is not enough. The reason is that we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;&quot;&gt;&lt;code&gt;empty&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; constructor function, which creates an allocator without any backing memory. Like our dummy allocator, it always returns an error on &lt;code&gt;alloc&lt;&#x2F;code&gt;. To fix this, we need to initialize the allocator after creating the heap:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_heap(
    mapper: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl Mapper&amp;lt;Size4KiB&amp;gt;,
    frame_allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
) -&amp;gt; Result&amp;lt;(), MapToError&amp;lt;Size4KiB&amp;gt;&amp;gt; {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; […] map all heap pages to physical frames

    &#x2F;&#x2F; new
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }

    Ok(())
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;lock_api&#x2F;0.3.3&#x2F;lock_api&#x2F;struct.Mutex.html#method.lock&quot;&gt;&lt;code&gt;lock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method on the inner spinlock of the &lt;code&gt;LockedHeap&lt;&#x2F;code&gt; type to get an exclusive reference to the wrapped &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;&quot;&gt;&lt;code&gt;Heap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance, on which we then call the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;&quot;&gt;&lt;code&gt;init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method with the heap bounds as arguments. It is important that we initialize the heap &lt;em&gt;after&lt;&#x2F;em&gt; mapping the heap pages, since the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;&quot;&gt;&lt;code&gt;init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function already tries to write to the heap memory.&lt;&#x2F;p&gt;
&lt;p&gt;After initializing the heap, we can now use all allocation and collection types of the built-in &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate without error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::{boxed::Box, vec, vec::Vec, rc::Rc};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; […] initialize interrupts, mapper, frame_allocator, heap

    &#x2F;&#x2F; allocate a number on the heap
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_value = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap_value at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, heap_value);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create a dynamically sized vector
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; vec = Vec::new();
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;500 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        vec.push(i);
    }
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;vec at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, vec.as_slice());

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create a reference counted vector -&amp;gt; will be freed when count reaches 0
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; reference_counted = Rc::new(vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; cloned_reference = reference_counted.clone();
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;current reference count is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, Rc::strong_count(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cloned_reference));
    core::mem::drop(reference_counted);
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;reference count is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; now&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, Rc::strong_count(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cloned_reference));

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; […] call `test_main` in test context
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code example shows some uses of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;vec&#x2F;&quot;&gt;&lt;code&gt;Vec&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;rc&#x2F;&quot;&gt;&lt;code&gt;Rc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; types. For the &lt;code&gt;Box&lt;&#x2F;code&gt; and &lt;code&gt;Vec&lt;&#x2F;code&gt; types we print the underlying heap pointers using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;fmt&#x2F;trait.Pointer.html&quot;&gt;&lt;code&gt;{:p}&lt;&#x2F;code&gt; formatting specifier&lt;&#x2F;a&gt;. For showcasing &lt;code&gt;Rc&lt;&#x2F;code&gt;, we create a reference counted heap value and use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;rc&#x2F;struct.Rc.html#method.strong_count&quot;&gt;&lt;code&gt;Rc::strong_count&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to print the current reference count, before and after dropping an instance (using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;mem&#x2F;fn.drop.html&quot;&gt;&lt;code&gt;core::mem::drop&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;When we run it, we see the following:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;heap-allocation&#x2F;qemu-alloc-showcase.png&quot; alt=&quot;QEMU printing ` heap_value at 0x444444440000 vec at 0x4444444408000 current reference count is 2 reference count is 1 now &quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As expected, we see that the &lt;code&gt;Box&lt;&#x2F;code&gt; and &lt;code&gt;Vec&lt;&#x2F;code&gt; values live on the heap, as indicated by the pointer starting with the &lt;code&gt;0x_4444_4444_*&lt;&#x2F;code&gt; prefix. The reference counted value also behaves as expected, with the reference count being 2 after the &lt;code&gt;clone&lt;&#x2F;code&gt; call, and 1 again after one of the instances was dropped.&lt;&#x2F;p&gt;
&lt;p&gt;The reason that the vector starts at offset &lt;code&gt;0x800&lt;&#x2F;code&gt; is not that the boxed value is &lt;code&gt;0x800&lt;&#x2F;code&gt; bytes large, but the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;vec&#x2F;struct.Vec.html#capacity-and-reallocation&quot;&gt;reallocations&lt;&#x2F;a&gt; that occur when the vector needs to increase its capacity. For example, when the vector&#x27;s capacity is 32 and we try to add the next element, the vector allocates a new backing array with capacity 64 behind the scenes and copies all elements over. Then it frees the old allocation.&lt;&#x2F;p&gt;
&lt;p&gt;Of course there are many more allocation and collection types in the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate that we can now all use in our kernel, including:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the thread-safe reference counted pointer &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;sync&#x2F;struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the owned string type &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;string&#x2F;struct.String.html&quot;&gt;&lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;macro.format.html&quot;&gt;&lt;code&gt;format!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;linked_list&#x2F;struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the growable ring buffer &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;vec_deque&#x2F;struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;binary_heap&#x2F;struct.BinaryHeap.html&quot;&gt;&lt;code&gt;BinaryHeap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; priority queue&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_set&#x2F;struct.BTreeSet.html&quot;&gt;&lt;code&gt;BTreeSet&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These types will become very useful when we want to implement thread lists, scheduling queues, or support for async&#x2F;await.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;adding-a-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-a-test&quot; aria-label=&quot;Anchor link for: adding-a-test&quot;&gt;🔗&lt;&#x2F;a&gt;Adding a Test&lt;&#x2F;h2&gt;
&lt;p&gt;To ensure that we don&#x27;t accidentally break our new allocation code, we should add an integration test for it. We start by creating a new &lt;code&gt;tests&#x2F;heap_allocation.rs&lt;&#x2F;code&gt; file with the following content:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(blog_os::test_runner)]
#![reexport_test_harness_main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::{entry_point, BootInfo};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

entry_point!(main);

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    unimplemented!();
}

#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    blog_os::test_panic_handler(info)
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We reuse the &lt;code&gt;test_runner&lt;&#x2F;code&gt; and &lt;code&gt;test_panic_handler&lt;&#x2F;code&gt; functions from our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;. Since we want to test allocations, we enable the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate through the &lt;code&gt;extern crate alloc&lt;&#x2F;code&gt; statement. For more information about the test boilerplate check out the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of the &lt;code&gt;main&lt;&#x2F;code&gt; function looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::allocator;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::{self, BootInfoFrameAllocator};
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::VirtAddr;

    blog_os::init();
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(phys_mem_offset) };
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        BootInfoFrameAllocator::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;boot_info.memory_map)
    };
    allocator::init_heap(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator)
        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap initialization failed&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    test_main();
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It is very similar to the &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, with the differences that we don&#x27;t invoke &lt;code&gt;println&lt;&#x2F;code&gt;, don&#x27;t include any example allocations, and call &lt;code&gt;test_main&lt;&#x2F;code&gt; unconditionally.&lt;&#x2F;p&gt;
&lt;p&gt;Now we&#x27;re ready to add a few test cases. First, we add a test that performs some simple allocations using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and checks the allocated values, to ensure that basic allocations work:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::boxed::Box;

#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;simple_allocation() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_value_1 = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_value_2 = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    assert_eq!(*heap_value_1, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    assert_eq!(*heap_value_2, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Most importantly, this test verifies that no allocation error occurs.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we iteratively build a large vector, to test both large allocations and multiple allocations (due to reallocations):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::vec::Vec;

#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;large_vec() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; n = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; vec = Vec::new();
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;n {
        vec.push(i);
    }
    assert_eq!(vec.iter().sum::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;(), (n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) * n &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We verify the sum by comparing it with the formula for the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums&quot;&gt;n-th partial sum&lt;&#x2F;a&gt;. This gives us some confidence that the allocated values are all correct.&lt;&#x2F;p&gt;
&lt;p&gt;As a third test, we create ten thousand allocations after each other:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::allocator::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;many_boxes() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x = Box::new(i);
        assert_eq!(*x, i);
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This test ensures that the allocator reuses freed memory for subsequent allocations since it would run out of memory otherwise. This might seem like an obvious requirement for an allocator, but there are allocator designs that don&#x27;t do this. An example is the bump allocator design that will be explained in the next post.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s run our new integration test:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo test --test heap_allocation
[…]
Running 3 tests
simple_allocation... [ok]
large_vec... [ok]
many_boxes... [ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All three tests succeeded! You can also invoke &lt;code&gt;cargo test&lt;&#x2F;code&gt; (without &lt;code&gt;--test&lt;&#x2F;code&gt; argument) to run all unit and integration tests.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;This post gave an introduction to dynamic memory and explained why and where it is needed. We saw how Rust&#x27;s borrow checker prevents common vulnerabilities and learned how Rust&#x27;s allocation API works.&lt;&#x2F;p&gt;
&lt;p&gt;After creating a minimal implementation of Rust&#x27;s allocator interface using a dummy allocator, we created a proper heap memory region for our kernel. For that we defined a virtual address range for the heap and then mapped all pages of that range to physical frames using the &lt;code&gt;Mapper&lt;&#x2F;code&gt; and &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; from the previous post.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we added a dependency on the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate to add a proper allocator to our kernel. With this allocator, we were able to use &lt;code&gt;Box&lt;&#x2F;code&gt;, &lt;code&gt;Vec&lt;&#x2F;code&gt;, and other allocation and collection types from the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;While we already added heap allocation support in this post, we left most of the work to the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate. The next post will show in detail how an allocator can be implemented from scratch. It will present multiple possible allocator designs, shows how to implement simple versions of them, and explain their advantages and drawbacks.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in May 2019</title>
                <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2019-06-03/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2019-06-03/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and to the used tools. I was quite busy with my master thesis this month, so I didn&#x27;t have the time to create new content or major new features. However, there were quite a few minor updates.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;70&quot;&gt;Use cast crate instead of usize_conversions crate&lt;&#x2F;a&gt; (released as version 0.5.5).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;71&quot;&gt;Make FrameAllocator an unsafe trait&lt;&#x2F;a&gt; (released as version 0.6.0).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;76&quot;&gt;Change Port::read and PortReadOnly::read to take &amp;amp;mut self&lt;&#x2F;a&gt; (released as version 0.7.0).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;npmccallum&quot;&gt;@npmccallum&lt;&#x2F;a&gt; started working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;issues&#x2F;72&quot;&gt;moving the type declarations to a separate crate&lt;&#x2F;a&gt; to make them usable for more projects. We created the experimental &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64_types&#x2F;&quot;&gt;x86_64_types&lt;&#x2F;a&gt; crate for this.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;Cargo-Xbuild&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;commit&#x2F;bd73f5a1b975f1938abd5b4c17a048d2018741b7&quot;&gt;Make backtraces optional&lt;&#x2F;a&gt; to remove the transitive dependency on the &lt;code&gt;cc&lt;&#x2F;code&gt; crate, which has additional &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;alexcrichton&#x2F;cc-rs#compile-time-requirements&quot;&gt;compile-time requirements&lt;&#x2F;a&gt; (e.g. a working &lt;code&gt;gcc&lt;&#x2F;code&gt; installation). These requirements caused &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;issues&#x2F;612&quot;&gt;problems for some people&lt;&#x2F;a&gt;, so we decided to disable backtraces by default. Released as version 0.5.9.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;32&quot;&gt;Error when the sysroot path contains spaces&lt;&#x2F;a&gt;: This pull request adds a special error message that points to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;6139&quot;&gt;rust-lang&#x2F;cargo#6139&lt;&#x2F;a&gt; when a sysroot path contains spaces. This should avoid the regular confusion, e.g. &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;issues&#x2F;464#issuecomment-427793367&quot;&gt;here&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;issues&#x2F;403#issuecomment-483046786&quot;&gt;here&lt;&#x2F;a&gt;, or &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;issues&#x2F;403#issuecomment-487313363&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;33&quot;&gt;Add a &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2F;code&gt; environment variable to override sysroot path&lt;&#x2F;a&gt;: This feature is useful when the default sysroot path contains a space. Released as version 0.5.10.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;34&quot;&gt;Fix the new &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2F;code&gt; environment variable&lt;&#x2F;a&gt;. Released as version 0.5.11.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;40&quot;&gt;Update Azure Pipelines CI script&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Build all branches instead of just &lt;code&gt;master&lt;&#x2F;code&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;bors.tech&#x2F;&quot;&gt;bors&lt;&#x2F;a&gt; &lt;code&gt;staging&lt;&#x2F;code&gt; branch.&lt;&#x2F;li&gt;
&lt;li&gt;Rustup is now included in the official Windows image of Azure Pipelines, so we don&#x27;t need to install it again.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;Bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rybot666&quot;&gt;@rybot666&lt;&#x2F;a&gt; started working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;issues&#x2F;24&quot;&gt;porting the 16-bit assembly of the bootloader to Rust&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;Bootimage&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;toothbrush7777777&quot;&gt;@toothbrush7777777&lt;&#x2F;a&gt; landed a pull request to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;39&quot;&gt;pad the boot image to a hard disk block size&lt;&#x2F;a&gt;. This is required for booting the image in VirtualBox. Released as version 0.7.4.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;41&quot;&gt;Set &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2F;code&gt; when building bootloader&lt;&#x2F;a&gt;. Released as version 0.7.5.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;Blog OS&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;600&quot;&gt;Update to version 0.6.0 of x86_64&lt;&#x2F;a&gt;, which made the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; trait unsafe to implement.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;604&quot;&gt;Use &lt;code&gt;-serial stdio&lt;&#x2F;code&gt; instead of &lt;code&gt;-serial mon:stdio&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as QEMU arguments when testing.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;606&quot;&gt;Update x86_64 to version 0.7.0&lt;&#x2F;a&gt;, which changed the &lt;code&gt;Port::read&lt;&#x2F;code&gt; method to take &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; instead of &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;josephlr&quot;&gt;@josephlr&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;609&quot;&gt;replaced some leftover tabs with spaces&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;611&quot;&gt;Rewrite &lt;code&gt;CompareMessage&lt;&#x2F;code&gt; struct to check the whole string&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in April 2019</title>
                <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/status-update/2019-05-01/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/status-update/2019-05-01/</guid>
                <description>&lt;p&gt;Lot&#x27;s of things changed in the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; series in the past month, both on the blog itself and in the tools behind the scenes. This post gives an overview of the most important updates.&lt;&#x2F;p&gt;
&lt;p&gt;This post is an experiment inspired by &lt;a href=&quot;https:&#x2F;&#x2F;this-week-in-rust.org&#x2F;&quot;&gt;&lt;em&gt;This Week in Rust&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and similar series. The goal is to provide a resource that allows following the project more closely and staying up-to-date with the changes in the tools&#x2F;libraries behind the scenes. If enough people find this useful, I will try to turn this in a semi-regular series.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;Bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;The build system of the bootloader was rewritten to do a proper linking instead of appending the kernel executable manually like before. The relevant pull requests are &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;51&quot;&gt;&lt;em&gt;Rewrite build system&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;53&quot;&gt;&lt;em&gt;Updates for new build system&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. These (breaking) changes were released as version &lt;code&gt;0.5.0&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;blob&#x2F;master&#x2F;Changelog.md#050&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;To make the bootloader work with future versions of &lt;code&gt;bootimage&lt;&#x2F;code&gt;, a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;commit&#x2F;33b8ce6059e90485c56883b23d4834d06ddfd517&quot;&gt;&lt;code&gt;package.metadata.bootloader.target&lt;&#x2F;code&gt; key was added&lt;&#x2F;a&gt; to the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; of the bootloader. This key specifies the name of the target JSON file, so that &lt;code&gt;bootimage&lt;&#x2F;code&gt; knows which &lt;code&gt;--target&lt;&#x2F;code&gt; argument to pass. This change was released as version &lt;code&gt;0.5.1&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;blob&#x2F;master&#x2F;Changelog.md#051&quot;&gt;changelog&lt;&#x2F;a&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;55&quot;&gt;&lt;em&gt;Version 0.6.0&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request, the &lt;code&gt;#[cfg(not(test))]&lt;&#x2F;code&gt; attribute was removed from the &lt;code&gt;entry_point&lt;&#x2F;code&gt; macro. This makes it possible to use the macro together with &lt;code&gt;cargo xtest&lt;&#x2F;code&gt; and a custom test framework. Since the change is breaking, it was released as version &lt;code&gt;0.6.0&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;blob&#x2F;master&#x2F;Changelog.md#060&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;Bootimage&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;34&quot;&gt;&lt;em&gt;Rewrite bootimage for new bootloader build system&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request completely revamped the implementation of the crate. This was released as version &lt;code&gt;0.7.0&lt;&#x2F;code&gt;. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;blob&#x2F;master&#x2F;Changelog.md#070&quot;&gt;changelog&lt;&#x2F;a&gt; for a list of changes.
&lt;ul&gt;
&lt;li&gt;The rewrite had the unintended side-effect that &lt;code&gt;bootimage run&lt;&#x2F;code&gt; no longer ignored executables named &lt;code&gt;test-*&lt;&#x2F;code&gt;, so that an additional &lt;code&gt;--bin&lt;&#x2F;code&gt; argument was required for specifying which executable to run. To avoid breaking users of &lt;code&gt;bootimage test&lt;&#x2F;code&gt;, we yanked version &lt;code&gt;0.7.0&lt;&#x2F;code&gt;. After &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;commit&#x2F;8746c15bf326cf8438a4e64ffdda332fbe59e30d&quot;&gt;fixing the issue&lt;&#x2F;a&gt;, version &lt;code&gt;0.7.1&lt;&#x2F;code&gt; was released (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;blob&#x2F;master&#x2F;Changelog.md#071&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;36&quot;&gt;&lt;em&gt;New features for &lt;code&gt;bootimage runner&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request added support for additional arguments and various functionality for supporting &lt;code&gt;cargo xtest&lt;&#x2F;code&gt;. The changes were released as version &lt;code&gt;0.7.2&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;blob&#x2F;master&#x2F;Changelog.md#072&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;An argument parsing bug that broke the new &lt;code&gt;cargo bootimage&lt;&#x2F;code&gt; subcommand on Windows was &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;commit&#x2F;101eb43de403fd9f3cb3f044e2c263356d2c179a&quot;&gt;fixed&lt;&#x2F;a&gt;. The fix was released as version &lt;code&gt;0.7.3&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;Blog OS&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Performed an &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;575&quot;&gt;&lt;em&gt;Update to new bootloader 0.5.1 and bootimage 0.7.2&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. Apart from requiring the &lt;code&gt;llvm-tools-preview&lt;&#x2F;code&gt; rustup component, this only changes version numbers.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;577&quot;&gt;&lt;em&gt;Rewrite the linking section of &amp;quot;A Freestanding Rust Binary&amp;quot;&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request updated the first post to compile for the bare-metal &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2F;code&gt; target instead of adding linker arguments for Linux&#x2F;Windows&#x2F;macOS.&lt;&#x2F;li&gt;
&lt;li&gt;Since the blog came close to the free bandwidth limit of Netlify, we needed to &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;579&quot;&gt;&lt;em&gt;Migrate from Netlify to Github Pages&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; to avoid additional fees.&lt;&#x2F;li&gt;
&lt;li&gt;With the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;582&quot;&gt;&lt;em&gt;Minimal Rust Kernel: Use a runner to make cargo xrun work&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request, we integrated the new &lt;code&gt;bootimage runner&lt;&#x2F;code&gt; into the blog.
&lt;ul&gt;
&lt;li&gt;The required updates to the &lt;code&gt;post-02&lt;&#x2F;code&gt; and &lt;code&gt;post-03&lt;&#x2F;code&gt; branches were performed in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;585&quot;&gt;&lt;em&gt;Add &lt;code&gt;.cargo&#x2F;config&lt;&#x2F;code&gt; file to post-02 branch&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;586&quot;&gt;&lt;em&gt;Merge the changes from #585 into the post-03 branch&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull requests.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;584&quot;&gt;&lt;em&gt;New testing post&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request, we replaced the previous &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;unit-testing&#x2F;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;integration-tests&#x2F;&quot;&gt;&lt;em&gt;Integration Tests&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; with the new &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, which uses &lt;code&gt;cargo xtest&lt;&#x2F;code&gt; and a custom test framework for running tests.
&lt;ul&gt;
&lt;li&gt;The required updates for the &lt;code&gt;post-04&lt;&#x2F;code&gt; branch were performed in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;587&quot;&gt;&lt;em&gt;Implement code for new testing post in post-xx branches&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request. The updates for the other &lt;code&gt;post-*&lt;&#x2F;code&gt; branches were pushed manually to avoid spamming the repository with pull requests. You can find a list of the commits in the pull request description.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;pull&#x2F;595&quot;&gt;&lt;em&gt;Avoid generic impl trait parameters in BootInfoFrameAllocator&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request made the &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt; non-generic by reconstructing the frame iterator on every allocation. This way, we avoid using a &lt;code&gt;impl Trait&lt;&#x2F;code&gt; type parameter, which makes it &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;issues&#x2F;593&quot;&gt;impossible to store the type in a &lt;code&gt;static&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;60367&quot;&gt;rust-lang&#x2F;rust#60367&lt;&#x2F;a&gt; for the fundamental problem.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Advanced Paging</title>
                <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/advanced-paging/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/advanced-paging/</guid>
                <description>&lt;p&gt;This post explains techniques to make the physical page table frames accessible to our kernel. It then uses such a technique to implement a function that translates virtual to physical addresses. It also explains how to create new mappings in the page tables.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;advanced-paging&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;5c0fb63f33380fc8596d7166c2ebde03ef3d6726&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;🔗&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we learned how a recursive level 4 table entry can be used to map all page table frames to calculatable virtual addresses. We used this technique to implement an address translation function and to create a new mapping in the page tables.&lt;&#x2F;p&gt;
&lt;p&gt;We saw that the creation of new mappings requires unused frames for creating new page tables. Such a frame allocator can be implemented on top of the boot information structure that the bootloader passes to our kernel.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post will create a heap memory region for our kernel, which will allow us to &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;allocate memory&lt;&#x2F;a&gt; and use various &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;index.html&quot;&gt;collection types&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Hardware Interrupts</title>
                <pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/hardware-interrupts/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/hardware-interrupts/</guid>
                <description>&lt;p&gt;In this post we set up the programmable interrupt controller to correctly forward hardware interrupts to the CPU. To handle these interrupts we add new entries to our interrupt descriptor table, just like we did for our exception handlers. We will learn how to get periodic timer interrupts and how to get input from the keyboard.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;hardware-interrupts&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-07&quot;&gt;&lt;code&gt;post-07&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;🔗&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;This post explained how to enable and handle external interrupts. We learned about the 8259 PIC and its primary&#x2F;secondary layout, the remapping of the interrupt numbers, and the &amp;quot;end of interrupt&amp;quot; signal. We implemented handlers for the hardware timer and the keyboard and learned about the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction, which halts the CPU until the next interrupt.&lt;&#x2F;p&gt;
&lt;p&gt;Now we are able to interact with our kernel and have some fundamental building blocks for creating a small shell or simple games.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;Timer interrupts are essential for an operating system, because they provide a way to periodically interrupt the running process and regain control in the kernel. The kernel can then switch to a different process and create the illusion that multiple processes run in parallel.&lt;&#x2F;p&gt;
&lt;p&gt;But before we can create processes or threads, we need a way to allocate memory for them. The next posts will explore memory management to provide this fundamental building block.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Function Invocation</title>
                <pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/function-invocation/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/function-invocation/</guid>
                <description>&lt;p&gt;Functions are the other fundamental building block of programming in Elijah.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;function-invocation&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-05&quot;&gt;&lt;code&gt;post-05&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;normal-functions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#normal-functions&quot; aria-label=&quot;Anchor link for: normal-functions&quot;&gt;🔗&lt;&#x2F;a&gt;Normal Functions&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;constructors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#constructors&quot; aria-label=&quot;Anchor link for: constructors&quot;&gt;🔗&lt;&#x2F;a&gt;Constructors&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;properties&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#properties&quot; aria-label=&quot;Anchor link for: properties&quot;&gt;🔗&lt;&#x2F;a&gt;Properties&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;modifiers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#modifiers&quot; aria-label=&quot;Anchor link for: modifiers&quot;&gt;🔗&lt;&#x2F;a&gt;Modifiers&lt;&#x2F;h2&gt;
&lt;p&gt;in out const ref&lt;&#x2F;p&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;🔗&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;too-much-magic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#too-much-magic&quot; aria-label=&quot;Anchor link for: too-much-magic&quot;&gt;🔗&lt;&#x2F;a&gt;Too much Magic?&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.InterruptDescriptorTable.html&quot;&gt;&lt;code&gt;InterruptDescriptorTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type made the exception handling process relatively straightforward and painless. If this was too much magic for you and you like to learn all the gory details of exception handling, we got you covered: Our &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;edition-2&#x2F;&quot;&gt;“Handling Exceptions with Naked Functions”&lt;&#x2F;a&gt; series shows how to handle exceptions without the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and also creates its own IDT type. Historically, these posts were the main exception handling posts before the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate existed. Note that these posts are based on the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;edition-2&#x2F;&quot;&gt;first edition&lt;&#x2F;a&gt; of this blog and might be out of date.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve successfully caught our first exception and returned from it! The next step is to ensure that we catch all exceptions, because an uncaught exception causes a fatal &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Triple_Fault&quot;&gt;triple fault&lt;&#x2F;a&gt;, which leads to a system reset. The next post explains how we can avoid this by correctly catching &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Double_Fault#Double_Fault&quot;&gt;double faults&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Integration Tests</title>
                <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/integration-tests/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/integration-tests/</guid>
                <description>&lt;p&gt;To complete the testing picture we implement a basic integration test framework, which allows us to run tests on the target system. The idea is to run tests inside QEMU and report the results back to the host through the serial port.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;integration-tests&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-05&quot;&gt;&lt;code&gt;post-05&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;🔗&lt;&#x2F;a&gt;Requirements&lt;&#x2F;h2&gt;
&lt;p&gt;This post builds upon the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;unit-testing&#x2F;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, so you need to follow it first. Alternatively, consider reading the new &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post instead, which replaces both &lt;em&gt;Unit Testing&lt;&#x2F;em&gt; and this post. The new posts implements similar functionality, but integrates it directly in &lt;code&gt;cargo xtest&lt;&#x2F;code&gt;, so that both unit and integration tests run in a realistic environment inside QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;🔗&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;In the previous post we added support for unit tests. The goal of unit tests is to test small components in isolation to ensure that each of them works as intended. The tests are run on the host machine and thus shouldn&#x27;t rely on architecture specific functionality.&lt;&#x2F;p&gt;
&lt;p&gt;To test the interaction of the components, both with each other and the system environment, we can write &lt;em&gt;integration tests&lt;&#x2F;em&gt;. Compared to unit tests, ìntegration tests are more complex, because they need to run in a realistic environment. What this means depends on the application type. For example, for webserver applications it often means to set up a database instance. For an operating system kernel like ours, it means that we run the tests on the target hardware without an underlying operating system.&lt;&#x2F;p&gt;
&lt;p&gt;Running on the target architecture allows us to test all hardware specific code such as the VGA buffer or the effects of &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Page_table&quot;&gt;page table&lt;&#x2F;a&gt; modifications. It also allows us to verify that our kernel boots without problems and that no &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;CPU exception&lt;&#x2F;a&gt; occurs.&lt;&#x2F;p&gt;
&lt;p&gt;In this post we will implement a very basic test framework that runs integration tests inside instances of the &lt;a href=&quot;https:&#x2F;&#x2F;www.qemu.org&#x2F;&quot;&gt;QEMU&lt;&#x2F;a&gt; virtual machine. It is not as realistic as running them on real hardware, but it is much simpler and should be sufficient as long as we only use standard hardware that is well supported in QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-serial-port&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-serial-port&quot; aria-label=&quot;Anchor link for: the-serial-port&quot;&gt;🔗&lt;&#x2F;a&gt;The Serial Port&lt;&#x2F;h2&gt;
&lt;p&gt;The naive way of doing an integration test would be to add some assertions in the code, launch QEMU, and manually check if a panic occurred or not. This is very cumbersome and not practical if we have hundreds of integration tests. So we want an automated solution that runs all tests and fails if not all of them pass.&lt;&#x2F;p&gt;
&lt;p&gt;Such an automated test framework needs to know whether a test succeeded or failed. It can&#x27;t look at the screen output of QEMU, so we need a different way of retrieving the test results on the host system. A simple way to achieve this is by using the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Serial_port&quot;&gt;serial port&lt;&#x2F;a&gt;, an old interface standard which is no longer found in modern computers. It is easy to program and QEMU can redirect the bytes sent over serial to the host&#x27;s standard output or a file.&lt;&#x2F;p&gt;
&lt;p&gt;The chips implementing a serial interface are called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_asynchronous_receiver-transmitter&quot;&gt;UARTs&lt;&#x2F;a&gt;. There are &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_asynchronous_receiver-transmitter#UART_models&quot;&gt;lots of UART models&lt;&#x2F;a&gt; on x86, but fortunately the only differences between them are some advanced features we don&#x27;t need. The common UARTs today are all compatible to the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;16550_UART&quot;&gt;16550 UART&lt;&#x2F;a&gt;, so we will use that model for our testing framework.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;port-i-o&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#port-i-o&quot; aria-label=&quot;Anchor link for: port-i-o&quot;&gt;🔗&lt;&#x2F;a&gt;Port I&#x2F;O&lt;&#x2F;h3&gt;
&lt;p&gt;There are two different approaches for communicating between the CPU and peripheral hardware on x86, &lt;strong&gt;memory-mapped I&#x2F;O&lt;&#x2F;strong&gt; and &lt;strong&gt;port-mapped I&#x2F;O&lt;&#x2F;strong&gt;. We already used memory-mapped I&#x2F;O for accessing the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;libraries-and-executables&#x2F;&quot;&gt;VGA text buffer&lt;&#x2F;a&gt; through the memory address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. This address is not mapped to RAM, but to some memory on the GPU.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, port-mapped I&#x2F;O uses a separate I&#x2F;O bus for communication. Each connected peripheral has one or more port numbers. To communicate with such an I&#x2F;O port there are special CPU instructions called &lt;code&gt;in&lt;&#x2F;code&gt; and &lt;code&gt;out&lt;&#x2F;code&gt;, which take a port number and a data byte (there are also variations of these commands that allow sending an &lt;code&gt;u16&lt;&#x2F;code&gt; or &lt;code&gt;u32&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The UART uses port-mapped I&#x2F;O. Fortunately there are already several crates that provide abstractions for I&#x2F;O ports and even UARTs, so we don&#x27;t need to invoke the &lt;code&gt;in&lt;&#x2F;code&gt; and &lt;code&gt;out&lt;&#x2F;code&gt; assembly instructions manually.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;🔗&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;We will use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;uart_16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate to initialize the UART and send data over the serial port. To add it as a dependency, we update our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; and &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;uart_16550 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2F;code&gt; crate contains a &lt;code&gt;SerialPort&lt;&#x2F;code&gt; struct that represents the UART registers, but we still need to construct an instance of it ourselves. For that we create a new &lt;code&gt;serial&lt;&#x2F;code&gt; module with the following content:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;serial.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;uart_16550::SerialPort;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Mutex;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static::lazy_static;

lazy_static! {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Mutex&amp;lt;SerialPort&amp;gt; = {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; serial_port = SerialPort::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x3F8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        serial_port.init();
        Mutex::new(serial_port)
    };
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To make the serial port easily usable, we add &lt;code&gt;serial_print!&lt;&#x2F;code&gt; and &lt;code&gt;serial_println!&lt;&#x2F;code&gt; macros:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[doc(hidden)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_print(args: ::core::fmt::Arguments) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_fmt(args).expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Printing to serial failed&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Prints to the host through the serial interface.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! serial_print {
    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        $crate::serial::_print(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)*));
    };
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Prints to the host through the serial interface, appending a newline.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! serial_println {
    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
        concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)*));
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;SerialPort&lt;&#x2F;code&gt; type already implements the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;trait.Write.html&quot;&gt;&lt;code&gt;fmt::Write&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, so we don&#x27;t need to provide an implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can print to the serial interface in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;

#[cfg(not(test))]
#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; prints to vga buffer
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;serial_println&lt;&#x2F;code&gt; macro lives directly under the root namespace because we used the &lt;code&gt;#[macro_export]&lt;&#x2F;code&gt; attribute, so importing it through &lt;code&gt;use crate::serial::serial_println&lt;&#x2F;code&gt; will not work.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qemu-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#qemu-arguments&quot; aria-label=&quot;Anchor link for: qemu-arguments&quot;&gt;🔗&lt;&#x2F;a&gt;QEMU Arguments&lt;&#x2F;h3&gt;
&lt;p&gt;To see the serial output in QEMU, we can use the &lt;code&gt;-serial&lt;&#x2F;code&gt; argument to redirect the output to stdout:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; qemu-system-x86_64 \
    -drive format=raw,file=target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-blog_os.bin \
    -serial mon:stdio
warning: TCG doesn&amp;#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
Hello Host!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you chose a different name than &lt;code&gt;blog_os&lt;&#x2F;code&gt;, you need to update the paths of course. Note that you can no longer exit QEMU through &lt;code&gt;Ctrl+c&lt;&#x2F;code&gt;. As an alternative you can use &lt;code&gt;Ctrl+a&lt;&#x2F;code&gt; and then &lt;code&gt;x&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As an alternative to this long command, we can pass the argument to &lt;code&gt;bootimage run&lt;&#x2F;code&gt;, with an additional &lt;code&gt;--&lt;&#x2F;code&gt; to separate the build arguments (passed to cargo) from the run arguments (passed to QEMU).&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run -- -serial mon:stdio
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of standard output, QEMU supports &lt;a href=&quot;https:&#x2F;&#x2F;qemu.weilnetz.de&#x2F;doc&#x2F;5.2&#x2F;system&#x2F;invocation.html#hxtool-9&quot;&gt;many more target devices&lt;&#x2F;a&gt;. For redirecting the output to a file, the argument is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;-serial file:output-file.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;shutting-down-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#shutting-down-qemu&quot; aria-label=&quot;Anchor link for: shutting-down-qemu&quot;&gt;🔗&lt;&#x2F;a&gt;Shutting Down QEMU&lt;&#x2F;h2&gt;
&lt;p&gt;Right now we have an endless loop at the end of our &lt;code&gt;_start&lt;&#x2F;code&gt; function and need to close QEMU manually. This does not work for automated tests. We could try to kill QEMU automatically from the host, for example after some special output was sent over serial, but this would be a bit hacky and difficult to get right. The cleaner solution would be to implement a way to shutdown our OS. Unfortunately this is relatively complex, because it requires implementing support for either the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;APM&quot;&gt;APM&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;ACPI&quot;&gt;ACPI&lt;&#x2F;a&gt; power management standard.&lt;&#x2F;p&gt;
&lt;p&gt;Luckily, there is an escape hatch: QEMU supports a special &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device, which provides an easy way to exit QEMU from the guest system. To enable it, we add the following argument to our QEMU command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;-device isa-debug-exit,iobase=0xf4,iosize=0x04
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;iobase&lt;&#x2F;code&gt; specifies on which port address the device should live (&lt;code&gt;0xf4&lt;&#x2F;code&gt; is a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;I&#x2F;O_Ports#The_list&quot;&gt;generally unused&lt;&#x2F;a&gt; port on the x86&#x27;s IO bus) and the &lt;code&gt;iosize&lt;&#x2F;code&gt; specifies the port size (&lt;code&gt;0x04&lt;&#x2F;code&gt; means four bytes). Now the guest can write a value to the &lt;code&gt;0xf4&lt;&#x2F;code&gt; port and QEMU will exit with &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exit_status&quot;&gt;exit status&lt;&#x2F;a&gt; &lt;code&gt;(passed_value &amp;lt;&amp;lt; 1) | 1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To write to the I&#x2F;O port, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.2&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exit_qemu() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port = Port::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    port.write(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We mark the function as &lt;code&gt;unsafe&lt;&#x2F;code&gt; because it relies on the fact that a special QEMU device is attached to the I&#x2F;O port with address &lt;code&gt;0xf4&lt;&#x2F;code&gt;. For the port type we choose &lt;code&gt;u32&lt;&#x2F;code&gt; because the &lt;code&gt;iosize&lt;&#x2F;code&gt; is 4 bytes. As value we write a zero, which causes QEMU to exit with exit status &lt;code&gt;(0 &amp;lt;&amp;lt; 1) | 1 = 1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Note that we could also use the exit status instead of the serial interface for sending the test results, for example &lt;code&gt;1&lt;&#x2F;code&gt; for success and &lt;code&gt;2&lt;&#x2F;code&gt; for failure. However, this wouldn&#x27;t allow us to send panic messages like the serial interface does and would also prevent us from replacing &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; with a proper shutdown someday. Therefore we continue to use the serial interface and just always write a &lt;code&gt;0&lt;&#x2F;code&gt; to the port.&lt;&#x2F;p&gt;
&lt;p&gt;We can now test the QEMU shutdown by calling &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; from our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; prints to vga buffer
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You should see that QEMU immediately closes after booting when executing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run -- -serial mon:stdio -device isa-debug-exit,iobase=0xf4,iosize=0x04
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;hiding-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hiding-qemu&quot; aria-label=&quot;Anchor link for: hiding-qemu&quot;&gt;🔗&lt;&#x2F;a&gt;Hiding QEMU&lt;&#x2F;h2&gt;
&lt;p&gt;We are now able to launch a QEMU instance that writes its output to the serial port and automatically exits itself when it&#x27;s done. So we no longer need the VGA buffer output or the graphical representation that still pops up. We can disable it by passing the &lt;code&gt;-display none&lt;&#x2F;code&gt; parameter to QEMU. The full command looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;qemu-system-x86_64 \
    -drive format=raw,file=target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-blog_os.bin \
    -serial mon:stdio \
    -device isa-debug-exit,iobase=0xf4,iosize=0x04 \
    -display none
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or, with &lt;code&gt;bootimage run&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run -- \
    -serial mon:stdio \
    -device isa-debug-exit,iobase=0xf4,iosize=0x04 \
    -display none
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now QEMU runs completely in the background and no window is opened anymore. This is not only less annoying, but also allows our test framework to run in environments without a graphical user interface, such as &lt;a href=&quot;https:&#x2F;&#x2F;travis-ci.com&#x2F;&quot;&gt;Travis CI&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test-organization&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-organization&quot; aria-label=&quot;Anchor link for: test-organization&quot;&gt;🔗&lt;&#x2F;a&gt;Test Organization&lt;&#x2F;h2&gt;
&lt;p&gt;Right now we&#x27;re doing the serial output and the QEMU exit from the &lt;code&gt;_start&lt;&#x2F;code&gt; function in our &lt;code&gt;main.rs&lt;&#x2F;code&gt; and can no longer run our kernel in a normal way. We could try to fix this by adding an &lt;code&gt;integration-test&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;features.html#the-features-section&quot;&gt;cargo feature&lt;&#x2F;a&gt; and using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;features&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;integration-test &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= []
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(feature &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;integration-test&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; prints to vga buffer

    &#x2F;&#x2F; normal execution

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

#[cfg(feature &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;integration-test&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    run_test_1();
    run_test_2();
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; run more tests

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, this approach has a big problem: All tests run in the same kernel instance, which means that they can influence each other. For example, if &lt;code&gt;run_test_1&lt;&#x2F;code&gt; misconfigures the system by loading an invalid &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Page_table&quot;&gt;page table&lt;&#x2F;a&gt;, it can cause &lt;code&gt;run_test_2&lt;&#x2F;code&gt; to fail. This isn&#x27;t something that we want because it makes it very difficult to find the actual cause of an error.&lt;&#x2F;p&gt;
&lt;p&gt;Instead, we want our test instances to be as independent as possible. If a test wants to destroy most of the system configuration to ensure that some property still holds in catastrophic situations, it should be able to do so without needing to restore a correct system state afterwards. This means that we need to launch a separate QEMU instance for each test.&lt;&#x2F;p&gt;
&lt;p&gt;With the above conditional compilation we only have two modes: Run the kernel normally or execute &lt;em&gt;all&lt;&#x2F;em&gt; integration tests. To run each test in isolation we would need a separate cargo feature for each test with that approach, which would result in very complex conditional compilation bounds and confusing code.&lt;&#x2F;p&gt;
&lt;p&gt;A better solution is to create an additional executable for each test.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;additional-test-executables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#additional-test-executables&quot; aria-label=&quot;Anchor link for: additional-test-executables&quot;&gt;🔗&lt;&#x2F;a&gt;Additional Test Executables&lt;&#x2F;h3&gt;
&lt;p&gt;Cargo allows to add &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;guide&#x2F;project-layout.html&quot;&gt;additional executables&lt;&#x2F;a&gt; to a project by putting them inside &lt;code&gt;src&#x2F;bin&lt;&#x2F;code&gt;. We can use that feature to create a separate executable for each integration test. For example, a &lt;code&gt;test-something&lt;&#x2F;code&gt; executable could be added like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;bin&#x2F;test-something.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]
#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

#[cfg(not(test))]
#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; run tests
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

#[cfg(not(test))]
#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By providing a new implementation for &lt;code&gt;_start&lt;&#x2F;code&gt; we can create a minimal test case that only tests one specific thing and is independent of the rest. For example, if we don&#x27;t print anything to the VGA buffer, the test still succeeds even if the &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; module is broken.&lt;&#x2F;p&gt;
&lt;p&gt;We can now run this executable in QEMU by passing a &lt;code&gt;--bin&lt;&#x2F;code&gt; argument to &lt;code&gt;bootimage&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run --bin test-something
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It should build the &lt;code&gt;test-something.rs&lt;&#x2F;code&gt; executable instead of &lt;code&gt;main.rs&lt;&#x2F;code&gt; and launch an empty QEMU window (since we don&#x27;t print anything). So this approach allows us to create completely independent executables without cargo features or conditional compilation, and without cluttering our &lt;code&gt;main.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;However, there is a problem: This is a completely separate executable, which means that we can&#x27;t access any functions from our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, including &lt;code&gt;serial_println&lt;&#x2F;code&gt; and &lt;code&gt;exit_qemu&lt;&#x2F;code&gt;. Duplicating the code would work, but we would also need to copy everything we want to test. This would mean that we no longer test the original function but only a possibly outdated copy.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately there is a way to share most of the code between our &lt;code&gt;main.rs&lt;&#x2F;code&gt; and the testing binaries: We move most of the code from our &lt;code&gt;main.rs&lt;&#x2F;code&gt; to a library that we can include from all executables.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;split-off-a-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#split-off-a-library&quot; aria-label=&quot;Anchor link for: split-off-a-library&quot;&gt;🔗&lt;&#x2F;a&gt;Split Off A Library&lt;&#x2F;h3&gt;
&lt;p&gt;Cargo supports hybrid projects that are both a library and a binary. We only need to create a &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt; file and split the contents of our &lt;code&gt;main.rs&lt;&#x2F;code&gt; in the following way:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;lib.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t link the Rust standard library

&#x2F;&#x2F; NEW: We need to add `pub` here to make them accessible from the outside
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exit_qemu() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port = Port::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    port.write(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]
#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::println;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is the entry point, since the linker looks for a function
&#x2F;&#x2F;&#x2F; named `_start` by default.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we move everything except &lt;code&gt;_start&lt;&#x2F;code&gt; and &lt;code&gt;panic&lt;&#x2F;code&gt; to &lt;code&gt;lib.rs&lt;&#x2F;code&gt; and make the &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; and &lt;code&gt;serial&lt;&#x2F;code&gt; modules public. Everything should work exactly as before, including &lt;code&gt;bootimage run&lt;&#x2F;code&gt; and &lt;code&gt;cargo test&lt;&#x2F;code&gt;. To run tests only for the library part of our crate and avoid the additional output we can execute &lt;code&gt;cargo test --lib&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;test-basic-boot&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-basic-boot&quot; aria-label=&quot;Anchor link for: test-basic-boot&quot;&gt;🔗&lt;&#x2F;a&gt;Test Basic Boot&lt;&#x2F;h3&gt;
&lt;p&gt;We are finally able to create our first integration test executable. We start simple and only test that the basic boot sequence works and the &lt;code&gt;_start&lt;&#x2F;code&gt; function is called:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;bin&#x2F;test-basic-boot.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; disable all Rust-level entry points
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{exit_qemu, serial_println};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is the entry point, since the linker looks for a function
&#x2F;&#x2F;&#x2F; named `_start` by default.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ok&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}


&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;failed&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;{}&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We don&#x27;t do something special here, we just print &lt;code&gt;ok&lt;&#x2F;code&gt; if &lt;code&gt;_start&lt;&#x2F;code&gt; is called and &lt;code&gt;failed&lt;&#x2F;code&gt; with the panic message when a panic occurs. Let&#x27;s try it:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; bootimage run --bin test-basic-boot -- \
    -serial mon:stdio -display none \
    -device isa-debug-exit,iobase=0xf4,iosize=0x04
Building kernel
   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;…&#x2F;blog_os)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
    Updating registry `https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index`
Creating disk image at target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-test-basic-boot.bin
warning: TCG doesn&amp;#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
ok
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We got our &lt;code&gt;ok&lt;&#x2F;code&gt;, so it worked! Try inserting a &lt;code&gt;panic!()&lt;&#x2F;code&gt; before the &lt;code&gt;ok&lt;&#x2F;code&gt; printing, you should see output like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;failed
panicked at &amp;#39;explicit panic&amp;#39;, src&#x2F;bin&#x2F;test-basic-boot.rs:19:5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;test-panic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-panic&quot; aria-label=&quot;Anchor link for: test-panic&quot;&gt;🔗&lt;&#x2F;a&gt;Test Panic&lt;&#x2F;h3&gt;
&lt;p&gt;To test that our panic handler is really invoked on a panic, we create a &lt;code&gt;test-panic&lt;&#x2F;code&gt; test:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;bin&#x2F;test-panic.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]
#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{exit_qemu, serial_println};

#[cfg(not(test))]
#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    panic!();
}

#[cfg(not(test))]
#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ok&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This executable is almost identical to &lt;code&gt;test-basic-boot&lt;&#x2F;code&gt;, the only difference is that we print &lt;code&gt;ok&lt;&#x2F;code&gt; from our panic handler and invoke an explicit &lt;code&gt;panic()&lt;&#x2F;code&gt; in our &lt;code&gt;_start&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-test-runner&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-test-runner&quot; aria-label=&quot;Anchor link for: a-test-runner&quot;&gt;🔗&lt;&#x2F;a&gt;A Test Runner&lt;&#x2F;h2&gt;
&lt;p&gt;The final step is to create a test runner, a program that executes all integration tests and checks their results. The basic steps that it should do are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Look for integration tests in the current project, maybe by some convention (e.g. executables starting with &lt;code&gt;test-&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;Run all integration tests and interpret their results.
&lt;ul&gt;
&lt;li&gt;Use a timeout to ensure that an endless loop does not block the test runner forever.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Report the test results to the user and set a successful or failing exit status.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Such a test runner is useful to many projects, so we decided to add one to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bootimage-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bootimage-test&quot; aria-label=&quot;Anchor link for: bootimage-test&quot;&gt;🔗&lt;&#x2F;a&gt;Bootimage Test&lt;&#x2F;h3&gt;
&lt;p&gt;The test runner of the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool can be invoked via &lt;code&gt;bootimage test&lt;&#x2F;code&gt;. It uses the following conventions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;All executables starting with &lt;code&gt;test-&lt;&#x2F;code&gt; are treated as integration tests.&lt;&#x2F;li&gt;
&lt;li&gt;Tests must print either &lt;code&gt;ok&lt;&#x2F;code&gt; or &lt;code&gt;failed&lt;&#x2F;code&gt; over the serial port. When printing &lt;code&gt;failed&lt;&#x2F;code&gt; they can print additional information such as a panic message (in the next lines).&lt;&#x2F;li&gt;
&lt;li&gt;Tests are run with a timeout of 1 minute. If the test has not completed in time, it is reported as &amp;quot;timed out&amp;quot;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The &lt;code&gt;test-basic-boot&lt;&#x2F;code&gt; and &lt;code&gt;test-panic&lt;&#x2F;code&gt; tests we created above begin with &lt;code&gt;test-&lt;&#x2F;code&gt; and follow the &lt;code&gt;ok&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;failed&lt;&#x2F;code&gt; conventions, so they should work with &lt;code&gt;bootimage test&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; bootimage test
test-panic
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
Ok

test-basic-boot
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
Ok

test-something
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
Timed Out

The following tests failed:
    test-something: TimedOut
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that our &lt;code&gt;test-panic&lt;&#x2F;code&gt; and &lt;code&gt;test-basic-boot&lt;&#x2F;code&gt; succeeded and that the &lt;code&gt;test-something&lt;&#x2F;code&gt; test timed out after one minute. We no longer need &lt;code&gt;test-something&lt;&#x2F;code&gt;, so we delete it (if you haven&#x27;t done already). Now &lt;code&gt;bootimage test&lt;&#x2F;code&gt; should execute successfully.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we learned about the serial port and port-mapped I&#x2F;O and saw how to configure QEMU to print serial output to the command line. We also learned a trick how to exit QEMU without needing to implement a proper shutdown.&lt;&#x2F;p&gt;
&lt;p&gt;We then split our crate into a library and binary part in order to create additional executables for integration tests. We added two example tests for testing that the &lt;code&gt;_start&lt;&#x2F;code&gt; function is correctly called and that a &lt;code&gt;panic&lt;&#x2F;code&gt; invokes our panic handler. Finally, we presented &lt;code&gt;bootimage test&lt;&#x2F;code&gt; as a basic test runner for our integration tests.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a working integration test framework and can finally start to implement functionality in our kernel. We will continue to use the test framework over the next posts to test new components we add.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the next post, we will explore &lt;em&gt;CPU exceptions&lt;&#x2F;em&gt;. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called “page fault”). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Unit Testing</title>
                <pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate>
                <link>https://elijah-team.github.io/programming-with-elijah/unit-testing/</link>
                <guid>https://elijah-team.github.io/programming-with-elijah/unit-testing/</guid>
                <description>&lt;p&gt;This post explores unit testing in &lt;code&gt;no_std&lt;&#x2F;code&gt; executables using Rust&#x27;s built-in test framework. We will adjust our code so that &lt;code&gt;cargo test&lt;&#x2F;code&gt; works and add some basic unit tests to our VGA buffer module.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;elijah-team&#x2F;programming-with-elijah&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;unit-testing&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;tree&#x2F;post-04&quot;&gt;&lt;code&gt;post-04&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;🔗&lt;&#x2F;a&gt;Requirements&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we explore how to execute &lt;code&gt;cargo test&lt;&#x2F;code&gt; on the host system (as a normal Linux&#x2F;Windows&#x2F;macOS executable). This only works if you don&#x27;t have a &lt;code&gt;.cargo&#x2F;config&lt;&#x2F;code&gt; file that sets a default target. If you followed the &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;namespaces-and-packages&#x2F;&quot;&gt;&lt;em&gt;Minimal Rust Kernel&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post before 2019-04-27, you should be fine. If you followed it after that date, you need to remove the &lt;code&gt;build.target&lt;&#x2F;code&gt; key from your &lt;code&gt;.cargo&#x2F;config&lt;&#x2F;code&gt; file and explicitly pass a target argument to &lt;code&gt;cargo xbuild&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Alternatively, consider reading the new &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post instead. It sets up a similar functionality as this post, but instead of running the tests on your host system, they are run in a realistic environment inside QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unit-tests-for-no-std-binaries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unit-tests-for-no-std-binaries&quot; aria-label=&quot;Anchor link for: unit-tests-for-no-std-binaries&quot;&gt;🔗&lt;&#x2F;a&gt;Unit Tests for &lt;code&gt;no_std&lt;&#x2F;code&gt; Binaries&lt;&#x2F;h2&gt;
&lt;p&gt;Rust has a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-00-testing.html&quot;&gt;built-in test framework&lt;&#x2F;a&gt; that is capable of running unit tests without the need to set anything up. Just create a function that checks some results through assertions and add the &lt;code&gt;#[test]&lt;&#x2F;code&gt; attribute to the function header. Then &lt;code&gt;cargo test&lt;&#x2F;code&gt; will automatically find and execute all test functions of your crate.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately it&#x27;s a bit more complicated for &lt;code&gt;no_std&lt;&#x2F;code&gt; applications such as our kernel. If we run &lt;code&gt;cargo test&lt;&#x2F;code&gt; (without adding any test yet), we get the following error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo test
   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;…&#x2F;blog_os)
error[E0152]: duplicate lang item found: `panic_impl`.
  --&amp;gt; src&#x2F;main.rs:35:1
   |
35 | &#x2F; fn panic(info: &amp;amp;PanicInfo) -&amp;gt; ! {
36 | |     println!(&amp;quot;{}&amp;quot;, info);
37 | |     loop {}
38 | | }
   | |_^
   |
   = note: first defined in crate `std`.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that unit tests are built for the host machine, with the &lt;code&gt;std&lt;&#x2F;code&gt; library included. This makes sense because they should be able to run as a normal application on the host operating system. Since the standard library has it&#x27;s own &lt;code&gt;panic_handler&lt;&#x2F;code&gt; function, we get the above error. To fix it, we use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2F;a&gt; to include our implementation of the panic handler only in non-test environments:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

#[cfg(not(test))] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; only compile when the test flag is not set
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only change is the added &lt;code&gt;#[cfg(not(test))]&lt;&#x2F;code&gt; attribute. The &lt;code&gt;#[cfg(…)]&lt;&#x2F;code&gt; attribute ensures that the annotated item is only included if the passed condition is met. The &lt;code&gt;test&lt;&#x2F;code&gt; configuration is set when the crate is compiled for unit tests. Through &lt;code&gt;not(…)&lt;&#x2F;code&gt; we negate the condition so that the language item is only compiled for non-test builds.&lt;&#x2F;p&gt;
&lt;p&gt;When we now try &lt;code&gt;cargo test&lt;&#x2F;code&gt; again, we get an ugly linker error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `cc` failed: exit code: 1
  |
  = note: &amp;quot;cc&amp;quot; &amp;quot;-Wl,--as-needed&amp;quot; &amp;quot;-Wl,-z,noexecstack&amp;quot; &amp;quot;-m64&amp;quot; &amp;quot;-L&amp;quot; &amp;quot;&#x2F;…&#x2F;lib&#x2F;rustlib&#x2F;x86_64-unknown-linux-gnu&#x2F;lib&amp;quot; […]
  = note: &#x2F;…&#x2F;blog_os-969bdb90d27730ed.2q644ojj2xqxddld.rcgu.o: In function `_start&amp;#39;:
          &#x2F;…&#x2F;blog_os&#x2F;src&#x2F;main.rs:17: multiple definition of `_start&amp;#39;
          &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-linux-gnu&#x2F;Scrt1.o:(.text+0x0): first defined here
          &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-linux-gnu&#x2F;Scrt1.o: In function `_start&amp;#39;:
          (.text+0x20): undefined reference to `main&amp;#39;
          collect2: error: ld returned 1 exit status

&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I shortened the output here because it is extremely verbose. The relevant part is at the bottom, after the second “note:”. We got two distinct errors here, “&lt;em&gt;multiple definition of &lt;code&gt;_start&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;” and “&lt;em&gt;undefined reference to &lt;code&gt;main&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;”.&lt;&#x2F;p&gt;
&lt;p&gt;The reason for the first error is that the test framework injects its own &lt;code&gt;main&lt;&#x2F;code&gt; and &lt;code&gt;_start&lt;&#x2F;code&gt; functions, which will run the tests when invoked. So we get two functions named &lt;code&gt;_start&lt;&#x2F;code&gt; when compiling in test mode, one from the test framework and the one we defined ourselves. To fix this, we need to exclude our &lt;code&gt;_start&lt;&#x2F;code&gt; function in that case, which we can do by marking it as &lt;code&gt;#[cfg(not(test))]&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ … }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The second problem is that we use the &lt;code&gt;#![no_main]&lt;&#x2F;code&gt; attribute for our crate, which suppresses any &lt;code&gt;main&lt;&#x2F;code&gt; generation, including the test &lt;code&gt;main&lt;&#x2F;code&gt;. To solve this, we use the &lt;a href=&quot;https:&#x2F;&#x2F;chrismorgan.info&#x2F;blog&#x2F;rust-cfg_attr.html&quot;&gt;&lt;code&gt;cfg_attr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; attribute to conditionally enable the &lt;code&gt;no_main&lt;&#x2F;code&gt; attribute only in non-test mode:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_main)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; instead of `#![no_main]`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now &lt;code&gt;cargo test&lt;&#x2F;code&gt; works:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo test
   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;…&#x2F;blog_os)
    [some warnings]
    Finished dev [unoptimized + debuginfo] target(s) in 0.98 secs
     Running target&#x2F;debug&#x2F;deps&#x2F;blog_os-1f08396a9eff0aa7

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test framework seems to work as intended. We don&#x27;t have any tests yet, but we already get a test result summary.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;silencing-the-warnings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#silencing-the-warnings&quot; aria-label=&quot;Anchor link for: silencing-the-warnings&quot;&gt;🔗&lt;&#x2F;a&gt;Silencing the Warnings&lt;&#x2F;h3&gt;
&lt;p&gt;We get a few warnings about unused imports, because we no longer compile our &lt;code&gt;_start&lt;&#x2F;code&gt; function. To silence such unused code warnings, we can add the following to the top of our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(test, allow(unused_imports))]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like before, the &lt;code&gt;cfg_attr&lt;&#x2F;code&gt; attribute sets the passed attribute if the passed condition holds. Here, we set the &lt;code&gt;allow(…)&lt;&#x2F;code&gt; attribute when compiling in test mode. We use the &lt;code&gt;allow&lt;&#x2F;code&gt; attribute to disable warnings for the &lt;code&gt;unused_import&lt;&#x2F;code&gt; &lt;em&gt;lint&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Lints are classes of warnings, for example &lt;code&gt;dead_code&lt;&#x2F;code&gt; for unused code or &lt;code&gt;missing-docs&lt;&#x2F;code&gt; for missing documentation. Lints can be set to four different states:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allow&lt;&#x2F;code&gt;: no errors, no warnings&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;warn&lt;&#x2F;code&gt;: causes a warning&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;deny&lt;&#x2F;code&gt;: causes a compilation error&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;forbid&lt;&#x2F;code&gt;: like &lt;code&gt;deny&lt;&#x2F;code&gt;, but can&#x27;t be overridden&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Some lints are &lt;code&gt;allow&lt;&#x2F;code&gt; by default (such as &lt;code&gt;missing-docs&lt;&#x2F;code&gt;), others are &lt;code&gt;warn&lt;&#x2F;code&gt; by default (such as &lt;code&gt;dead_code&lt;&#x2F;code&gt;), and some few are even &lt;code&gt;deny&lt;&#x2F;code&gt; by default.. The default can be overridden by the &lt;code&gt;allow&lt;&#x2F;code&gt;, &lt;code&gt;warn&lt;&#x2F;code&gt;, &lt;code&gt;deny&lt;&#x2F;code&gt; and &lt;code&gt;forbid&lt;&#x2F;code&gt; attributes. For a list of all lints, see &lt;code&gt;rustc -W help&lt;&#x2F;code&gt;. There is also the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang-nursery&#x2F;rust-clippy&quot;&gt;clippy&lt;&#x2F;a&gt; project, which provides many additional lints.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;including-the-standard-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#including-the-standard-library&quot; aria-label=&quot;Anchor link for: including-the-standard-library&quot;&gt;🔗&lt;&#x2F;a&gt;Including the Standard Library&lt;&#x2F;h3&gt;
&lt;p&gt;Unit tests run on the host machine, so it&#x27;s possible to use the complete standard library inside them. To link the standard library in test mode, we can make the &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; attribute conditional through &lt;code&gt;cfg_attr&lt;&#x2F;code&gt; too:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;-#![no_std]
+#![cfg_attr(not(test), no_std)]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;testing-the-vga-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-the-vga-module&quot; aria-label=&quot;Anchor link for: testing-the-vga-module&quot;&gt;🔗&lt;&#x2F;a&gt;Testing the VGA Module&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have set up the test framework, we can add a first unit test for our &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::*;

    #[test]
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;foo() {}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add the test in an inline &lt;code&gt;test&lt;&#x2F;code&gt; submodule. This isn&#x27;t necessary, but a common way to separate test code from the rest of the module. By adding the &lt;code&gt;#[cfg(test)]&lt;&#x2F;code&gt; attribute, we ensure that the module is only compiled in test mode. Through &lt;code&gt;use super::*&lt;&#x2F;code&gt;, we import all items of the parent module (the &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; module), so that we can test them easily.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;#[test]&lt;&#x2F;code&gt; attribute on the &lt;code&gt;foo&lt;&#x2F;code&gt; function tells the test framework that the function is an unit test. The framework will find it automatically, even if it&#x27;s private and inside a private module as in our case:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo test
   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;…&#x2F;blog_os)
    Finished dev [unoptimized + debuginfo] target(s) in 2.99 secs
     Running target&#x2F;debug&#x2F;deps&#x2F;blog_os-1f08396a9eff0aa7

running 1 test
test vga_buffer::test::foo ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that the test was found and executed. It didn&#x27;t panic, so it counts as passed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;constructing-a-writer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#constructing-a-writer&quot; aria-label=&quot;Anchor link for: constructing-a-writer&quot;&gt;🔗&lt;&#x2F;a&gt;Constructing a Writer&lt;&#x2F;h3&gt;
&lt;p&gt;In order to test the VGA methods, we first need to construct a &lt;code&gt;Writer&lt;&#x2F;code&gt; instance. Since we will need such an instance for other tests too, we create a separate function for it:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::*;

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_writer() -&amp;gt; Writer {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;std::boxed::Box;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; buffer = construct_buffer();
        Writer {
            column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            color_code: ColorCode::new(Color::Blue, Color::Magenta),
            buffer: Box::leak(Box::new(buffer)),
        }
    }

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_buffer() -&amp;gt; Buffer { … }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We set the initial column position to 0 and choose some arbitrary colors for foreground and background color. The difficult part is the buffer construction, it&#x27;s described in detail below. We then use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;boxed&#x2F;struct.Box.html#method.new&quot;&gt;&lt;code&gt;Box::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;boxed&#x2F;struct.Box.html#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to transform the created &lt;code&gt;Buffer&lt;&#x2F;code&gt; into a &lt;code&gt;&amp;amp;&#x27;static mut Buffer&lt;&#x2F;code&gt;, because the &lt;code&gt;buffer&lt;&#x2F;code&gt; field needs to be of that type.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;buffer-construction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buffer-construction&quot; aria-label=&quot;Anchor link for: buffer-construction&quot;&gt;🔗&lt;&#x2F;a&gt;Buffer Construction&lt;&#x2F;h4&gt;
&lt;p&gt;So how do we create a &lt;code&gt;Buffer&lt;&#x2F;code&gt; instance? The naive approach does not work unfortunately:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_buffer() -&amp;gt; Buffer {
    Buffer {
        chars: [[Volatile::new(empty_char()); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;],
    }
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;empty_char() -&amp;gt; ScreenChar {
    ScreenChar {
        ascii_character: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: ColorCode::new(Color::Green, Color::Brown),
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When running &lt;code&gt;cargo test&lt;&#x2F;code&gt; the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0277]: the trait bound `volatile::Volatile&amp;lt;vga_buffer::ScreenChar&amp;gt;: core::marker::Copy` is not satisfied
   --&amp;gt; src&#x2F;vga_buffer.rs:186:21
    |
186 |             chars: [[Volatile::new(empty_char); BUFFER_WIDTH]; BUFFER_HEIGHT],
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `core::marker::Copy` is not implemented for `volatile::Volatile&amp;lt;vga_buffer::ScreenChar&amp;gt;`
    |
    = note: the `Copy` trait is required because the repeated element will be copied
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that array construction in Rust requires that the contained type is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;&lt;code&gt;Copy&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. The &lt;code&gt;ScreenChar&lt;&#x2F;code&gt; is &lt;code&gt;Copy&lt;&#x2F;code&gt;, but the &lt;code&gt;Volatile&lt;&#x2F;code&gt; wrapper is not. There is currently no easy way to circumvent this without using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, but fortunately there is the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;array-init&quot;&gt;&lt;code&gt;array_init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate that provides a safe interface for such operations.&lt;&#x2F;p&gt;
&lt;p&gt;To use that crate, we add the following to our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dev-dependencies&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;array-init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.0.3&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we&#x27;re using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;specifying-dependencies.html#development-dependencies&quot;&gt;&lt;code&gt;dev-dependencies&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; table instead of the &lt;code&gt;dependencies&lt;&#x2F;code&gt; table, because we only need the crate for &lt;code&gt;cargo test&lt;&#x2F;code&gt; and not for a normal build.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can fix our &lt;code&gt;construct_buffer&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_buffer() -&amp;gt; Buffer {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;array_init::array_init;

    Buffer {
        chars: array_init(|_| array_init(|_| Volatile::new(empty_char()))),
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;array-init&quot;&gt;documentation of &lt;code&gt;array_init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for more information about using that crate.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-write-byte&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-write-byte&quot; aria-label=&quot;Anchor link for: testing-write-byte&quot;&gt;🔗&lt;&#x2F;a&gt;Testing &lt;code&gt;write_byte&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now we&#x27;re finally able to write a first unit test that tests the &lt;code&gt;write_byte&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in vga_buffer.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    […]

    #[test]
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_byte() {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer = construct_writer();
        writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;X&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;Y&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, row) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer.buffer.chars.iter().enumerate() {
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(j, screen_char) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row.iter().enumerate() {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char = screen_char.read();
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;X&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;Y&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char, empty_char());
                }
            }
        }
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We construct a &lt;code&gt;Writer&lt;&#x2F;code&gt;, write two bytes to it, and then check that the right screen characters were updated. When we run &lt;code&gt;cargo test&lt;&#x2F;code&gt;, we see that the test is executed and passes:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;running 1 test
test vga_buffer::test::write_byte ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Try to play around a bit with this function and verify that the test fails if you change something, e.g. if you print a third byte without adjusting the &lt;code&gt;for&lt;&#x2F;code&gt; loop.&lt;&#x2F;p&gt;
&lt;p&gt;(If you&#x27;re getting an “binary operation &lt;code&gt;==&lt;&#x2F;code&gt; cannot be applied to type &lt;code&gt;vga_buffer::ScreenChar&lt;&#x2F;code&gt;” error, you need to also derive &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cmp&#x2F;trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for &lt;code&gt;ScreenChar&lt;&#x2F;code&gt; and &lt;code&gt;ColorCode&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-strings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-strings&quot; aria-label=&quot;Anchor link for: testing-strings&quot;&gt;🔗&lt;&#x2F;a&gt;Testing Strings&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s add a second unit test to test formatted output and newline behavior:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    […]

    #[test]
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_formatted() {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer = construct_writer();
        writeln!(&amp;amp;mut writer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).unwrap();
        writeln!(&amp;amp;mut writer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).unwrap();

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, row) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer.buffer.chars.iter().enumerate() {
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(j, screen_char) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row.iter().enumerate() {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char = screen_char.read();
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;a&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;b&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;c&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char, empty_char());
                }
            }
        }
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this test we&#x27;re using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;macro.writeln.html&quot;&gt;&lt;code&gt;writeln!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro to print strings with newlines to the buffer. Most of the for loop is similar to the &lt;code&gt;write_byte&lt;&#x2F;code&gt; test and only verifies if the written characters are at the expected place. The new &lt;code&gt;if i &amp;gt;= BUFFER_HEIGHT - 2&lt;&#x2F;code&gt; case verifies that the empty lines that are shifted in on a newline have the &lt;code&gt;writer.color_code&lt;&#x2F;code&gt;, which is different from the initial color.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;more-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-tests&quot; aria-label=&quot;Anchor link for: more-tests&quot;&gt;🔗&lt;&#x2F;a&gt;More Tests&lt;&#x2F;h3&gt;
&lt;p&gt;We only present two basic tests here as an example, but of course many more tests are possible. For example a test that changes the writer color in between writes. Or a test that checks that the top line is correctly shifted off the screen on a newline. Or a test that checks that non-ASCII characters are handled correctly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;🔗&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Unit testing is a very useful technique to ensure that certain components have a desired behavior. Even if they cannot show the absence of bugs, they&#x27;re still an useful tool for finding them and especially for avoiding regressions.&lt;&#x2F;p&gt;
&lt;p&gt;This post explained how to set up unit testing in a Rust kernel. We now have a functioning test framework and can easily add tests by adding functions with a &lt;code&gt;#[test]&lt;&#x2F;code&gt; attribute. To run them, a short &lt;code&gt;cargo test&lt;&#x2F;code&gt; suffices. We also added a few basic tests for our VGA buffer as an example how unit tests could look like.&lt;&#x2F;p&gt;
&lt;p&gt;We also learned a bit about conditional compilation, Rust&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;unit-testing&#x2F;#silencing-the-warnings&quot;&gt;lint system&lt;&#x2F;a&gt;, how to &lt;a href=&quot;https:&#x2F;&#x2F;elijah-team.github.io&#x2F;programming-with-elijah&#x2F;unit-testing&#x2F;#buffer-construction&quot;&gt;initialize arrays with non-Copy types&lt;&#x2F;a&gt;, and the &lt;code&gt;dev-dependencies&lt;&#x2F;code&gt; section of the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;🔗&lt;&#x2F;a&gt;What&#x27;s next?&lt;&#x2F;h2&gt;
&lt;p&gt;We now have a working unit testing framework, which gives us the ability to test individual components. However, unit tests have the disadvantage that they run on the host machine and are thus unable to test how components interact with platform specific parts. For example, we can&#x27;t test the &lt;code&gt;println!&lt;&#x2F;code&gt; macro with an unit test because it wants to write at the VGA text buffer at address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;, which only exists in the bare metal environment.&lt;&#x2F;p&gt;
&lt;p&gt;The next post will close this gap by creating a basic &lt;em&gt;integration test&lt;&#x2F;em&gt; framework, which runs the tests in QEMU and thus has access to platform specific components. This will allow us to test the full system, for example that our kernel boots correctly or that no deadlock occurs on nested &lt;code&gt;println!&lt;&#x2F;code&gt; invocations.&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
